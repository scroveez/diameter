# ServerHTTP.pm
#
# Object for HTTP connections and debugging/monitoring/configuring
# of Radiator internals. Implements a simple web server
#
# This module contains copies of a number of JavaScript files sourced from the MythTv
# project, originally in mythplugins-0.20a.tar.bz2. These are included here under the LGPL. 
# The original source code is available at 
# ftp://ftp.osuosl.org/pub/mythtv/old_releases/mythplugins-0.20a.tar.bz2
# and is also available on request from OSC in goodies/mythtv-javascript-archives.
#
# Author: Mike McCauley (mikem@open.com.au)
# Copyright (C) 2007 Open System Consultants (Except for LGPL portions referred to above)
# $Id: ServerHTTP.pm,v 1.38 2012/12/13 20:19:47 mikem Exp $

package Radius::ServerHTTP;
@ISA = qw(Radius::Configurable Radius::StreamServer);
use Radius::Configurable;
use Radius::StreamServer;
use Radius::Context;
use Radius::Radius;
use Radius::Select;
use Radius::EAP;
use Radius::Documentation;
use Radius::HTTPRequest;
use Radius::AuthGeneric;
use Radius::AuthLogGeneric;
use Digest::MD5;
use CGI::Util;
use MIME::Base64;
use POSIX;
use File::Temp;
use strict;

$Radius::ServerHTTP::VERSION = '$Revision: 1.38 $';

%Radius::ServerHTTP::ConfigKeywords = 
(
 'Username'                    => 
 ['string', 
  'Fallback username to log in as. If there is no Username and no AuthBy clauses, users will not be required to authenticate in order to use the web interface', 
  0],

 'Password'                    => 
 ['string', 
  'Fallback password for Username. Password can be plaintext or any of the encrypted formats such as {crypt}....., {nthash}....., {SHA}...., {SSHA}....., {mysql}...., {msssql}...., {dechpwd}...., {MD5}......, {clear}.... etc', 
  0],

 'AuthByPolicy'                => 
 ['string', 
  'Specifies whether and how to continue authenticating after each AuthBy', 
  0],

 'AuditTrail'                => 
 ['string', 
  'Optional filename where all editing and configuration changes will be logged', 
  1],

 'AuthBy'                      => 
 ['objectlist', 
  'List of AuthBy clauses to use to handle authentication for new web connections. Requests are processed by each AuthBy in order until AuthByPolicy is satisifed. If there are no AuthBy clauses, the fallback Username and Password will be used', 
  0],

 'LogMicroseconds'             => 
 ['flag', 
  'When logging, include microseconds in the time (requires Time::HiRes)', 
  1],

 'SessionTimeout'              => 
 ['integer', 
  'Maximum time in seconds a session is permitted to continue without logging in again', 
  1],

 'LogMaxLines'                 => 
 ['integer', 'Maximumum number of recent log lines which will be displayed', 
  1],

 'Trace'                       => 
 ['integer', 
  'Logging trace level. Only messages with the specified or higher priority will be logged', 
  0],

 'DefaultPrivilegeLevel'                       => 
 ['integer', 
  'Privilege level to be used if a per-user Management-Policy-Id is not available from a successful authentication from the AuthBy list. The privilege level is a bitmask. The following privilege levels are defined, and may be logically or\'d together: 0 means no access, including no login permission. 1 means viewing basic status only. 2 means ability to reset the server. 4 means the ability to edit and change the running config (but not save it). 8 means the ability to save changes to the configuration. 15 means all privileges.',
  0],

 'AuthLog'                        => 
 ['objectlist', 
  'A list of AuthLog clauses that will be used to log authentication results', 
  1],

 'PageNotFoundHook'              => 
 ['hook', 
  'If a page is requested but not found in the set of built-in pages PageNotFoundHook is called to try to handle the request. PageNotFoundHook is passed the requested URI and a reference to the ServerHTTP connection. If it can handle the request, it returns an array of ($httpcode, $content, @headers), else undef.', 
  2],

 'AddToRequest'         => 
 ['string', 'This optional parameter adds any number of RADIUS attributes to the RADIUS requests generated by ServerHTTP. It can be used to tag authentication request requests for logging in users.', 1],


 );

# Privelege level definitions
$Radius::ServerHTTP::PRIV_LEVEL_NONE   = 0;
$Radius::ServerHTTP::PRIV_LEVEL_STATUS = 0x1;
$Radius::ServerHTTP::PRIV_LEVEL_RESET  = 0x2;
$Radius::ServerHTTP::PRIV_LEVEL_EDIT   = 0x4;
$Radius::ServerHTTP::PRIV_LEVEL_SAVE   = 0x8;

my @authbypolicies = 
    qw(
ContinueWhileIgnore ContinueUntilIgnore ContinueWhileAccept 
ContinueUntilAccept ContinueWhileReject ContinueUntilReject
       );

my @baudrates =
    qw(1200 2400 4800 9600 19200);

my @databits =
    qw(7 8);

my @parity =
    qw(odd even none);

my @stopbits =
    qw(1 2);

my @handshake =
    qw(none rts xoff);

my @fidelioprotocols =
    qw(tcp serial);

my @protocols =
    qw(tcp sctp);

my @roamprotocols =
    qw(radsec radius);

my @roamtransports =
    qw(tcp sctp udp);

my @certificatetypes =
    qw(PEM ASN1);

my @scopes =
    qw(base single sub);

my @sslverifytypes =
    qw(none optional require);

my @ldapversions =
    qw(2 3);

my @dereftypes=
    qw(never search find always);

my @saslmechanisms=
    qw(ANONYMOUS CRAM-MD5 DIGEST-MD5 EXTERNAL LOGIN PLAIN);

my @dbtypes=
    qw(AnyDBM_File NDBM_File DB_File GDBM_File SDBM_File ODBM_File);

my @authmodes=
    qw(PASS APOP BEST);

my @resultcodes=
    ('', 'ACCEPT', 'REJECT', 'IGNORE', 'CHALLENGE');

my @syslogsocktypes=
    qw(unix inet tcp udp stream console);

my @rsamobilepolicies=
    ('*System Policy: Password Only', 
     '*System Policy: RSA Mobile Only', 
     '*System Policy: RSA SecurID Only', 
     '*System Policy: RSA SecurID OR Password');

my @rsaampolicies=
    (
     'SecurID_Native',
     'RSA_Password',
     'OnDemand',
     'LDAP_Password',
     'Security_Questions',
     'SecurID_Proxy',
);

my @soaptrace=
    qw(transport dispatch result parameters headers objects method fault freeform trace debug all);

my @tacacsauthtypes=
    qw(PAP ASCII);

my @urlmethods=
    qw(GET POST);

my @urlpasswordencryptions=
    qw(Clear MD5 Crypt);

# List of valid NasType options
# REVISIT: get this from the filesystem somehow?
my @nastypes = 
    qw(unknown
Ascend           AscendSNMP     Bay4000SNMP     Bay5399SNMP
Bay8000SNMP      BayFinger      Bay             Cisco
CiscoSessionMIB  CiscoVPDN      Colubris        Computone
Cyclades         Hiper          ignore          Livingston
NomadixSNMP      NortelCVX1800  Patton          Ping
Portmaster3      Portmaster4    PortslaveLinux  PortslaveMoxa
Portslave        Redback        Shiva           TigrisNew
TigrisOld        Tigris         TotalControl    TotalControlSNMP
Xyplex
       );

my @detail_level_names = ('Basic Options',
			  'Advanced Options',
			  'Very Advanced Options',
			  'Deprecated Options');
# Full URL of the Radiator online reference manual.
my $refmanual = 'http://www.open.com.au/radiator/ref.pdf';

#####################################################################
sub new
{
    my ($class, @args) = @_;

    my $self = $class->SUPER::new(@args);

    # We act like a global logger and accumulate log messages in a ring buffer
    # We have to keep the buffer at this level rather than in the Connection
    # object, since the Connection for a single user session can come and go during 
    # the session, when the browser disconnects
    &Radius::LogGeneric::add_logger($self);

    $self->{log_index} = 0;
    return $self;
}

#####################################################################
sub activate
{
    my ($self) = @_;

    $self->Radius::Configurable::activate();
    $self->Radius::StreamServer::activate();

    # LogMaxLines might get smaller during activate
    $self->{log_index} = 0 if $self->{log_index} >= $self->{LogMaxLines};
    $self->{trace_nopacket} = 1;
}

#####################################################################
# Do per-instance default initialization
# This is called by Configurable during Configurable::new before
# the config file is parsed. Its a good place initialize instance 
# variables
# that might get overridden when the config file is parsed.
# Do per-instance default initialization. This is called after
# construction is complete
sub initialize
{
    my ($self) = @_;

    $self->Radius::Configurable::initialize();
    $self->Radius::StreamServer::initialize();

    $self->{Port} = 9048;
    $self->{SessionTimeout} = 3600;
    $self->{LogMaxLines} = 500;
    $self->{Trace} = 0;
    $self->{TLS_VerifyMode} = 0; # No peer verification
    $self->{DefaultPrivilegeLevel} = 1;
    $self->{ObjType} = 'ServerHTTP'; # Auto register with Configurable
}

#####################################################################
# This is called by StreamServer when a new connetion has been made
sub handle_new_connection
{
    my ($self, $newsocket) = @_;

    Radius::ServerHTTP::Connection->new
	($self, $newsocket,
	 SessionTimeout            => $self->{SessionTimeout},
	 Identifier                => $self->{Identifier},
	 MaxBufferSize             => $self->{MaxBufferSize},
	 UseSSL                    => $self->{UseSSL},
	 AddToRequest              => $self->{AddToRequest},
	 TLS_ExpectedPeerName      => $self->{TLS_ExpectedPeerName},
	 TLS_SubjectAltNameURI     => $self->{TLS_SubjectAltNameURI},
	 TLS_CertificateFingerprint=> $self->{TLS_CertificateFingerprint},
	 TLS_PrivateKeyPassword    => $self->{TLS_PrivateKeyPassword},
	 TLS_CertificateType       => $self->{TLS_CertificateType},
	 TLS_CertificateFile       => $self->{TLS_CertificateFile},
	 TLS_CertificateChainFile  => $self->{TLS_CertificateChainFile},
	 TLS_PrivateKeyFile        => $self->{TLS_PrivateKeyFile},
	 DisconnectErrorLevel      => $main::LOG_DEBUG,
	 );
}

#####################################################################
# Called when a message is to be logged
# See if our trace level is high enough and add it to the ring buffer
# for this client
# $s is the message string
# $p is the current packet if any
my $in_log;
sub log
{    
    my ($self, $priority, $s, $p) = @_;

    return unless $self->{LogMaxLines};
    return if $in_log++; # Prevent recursion
    if ($self->willLog($priority, $p))
    {	
	my $ctime = $self->format_ctime();
	$self->{log}[$self->{log_index}] = "$ctime: $Radius::Log::priorityToString[$priority]: $s";
	$self->{log_index} = ($self->{log_index} + 1) % $self->{LogMaxLines};
    }
    $self->SUPER::log($priority, $s, $p);
    $in_log = 0;
}

#####################################################################
# Return true if a message should be logged by this logger
# at the given log level (and matching an optional tracing username or predicate)
# If trace_predicate is not set, then trace_username (obsolete) will be used
sub willLog
{
    my ($self, $priority, $p) = @_;

    return (   $priority <= $self->{Trace} 
	    && (   (!$p && $self->{trace_nopacket})
	        || ($p && ($self->{trace_predicate} ? $self->{trace_predicate}->test($p) 
			       : (   ($self->{trace_username} eq '')
			          || ($p->getUserName() eq $self->{trace_username}))))));
}

#####################################################################
sub adjustTrace
{
    my ($self, $increment) = @_;
    return $self->{Trace} += $increment;
}

#####################################################################
sub destroy
{
    my ($self) = @_;

    &Radius::LogGeneric::remove_logger($self);
    $self->Radius::StreamServer::destroy();
}

#####################################################################
#####################################################################
#####################################################################
package Radius::ServerHTTP::Connection;
use vars qw(@ISA);
@ISA = qw(Radius::StreamServer::Connection);

# These allow us to call various AuthGeneric functions as if they were our own
# required by checkAttributes
*Radius::ServerHTTP::Connection::check_plain_password     =  *Radius::AuthGeneric::check_plain_password;
*Radius::ServerHTTP::Connection::check_nthash               =  *Radius::AuthGeneric::check_nthash;
*Radius::ServerHTTP::Connection::check_plaintext          =  *Radius::AuthGeneric::check_plaintext;

my $CRLF = $Radius::HTTPRequest::CRLF;
my %StatusCode = (
    100 => 'Continue',
    101 => 'Switching Protocols',
    102 => 'Processing',                      # WebDAV
    200 => 'OK',
    201 => 'Created',
    202 => 'Accepted',
    203 => 'Non-Authoritative Information',
    204 => 'No Content',
    205 => 'Reset Content',
    206 => 'Partial Content',
    207 => 'Multi-Status',                    # WebDAV
    300 => 'Multiple Choices',
    301 => 'Moved Permanently',
    302 => 'Found',
    303 => 'See Other',
    304 => 'Not Modified',
    305 => 'Use Proxy',
    307 => 'Temporary Redirect',
    400 => 'Bad Request',
    401 => 'Unauthorized',
    402 => 'Payment Required',
    403 => 'Forbidden',
    404 => 'Not Found',
    405 => 'Method Not Allowed',
    406 => 'Not Acceptable',
    407 => 'Proxy Authentication Required',
    408 => 'Request Timeout',
    409 => 'Conflict',
    410 => 'Gone',
    411 => 'Length Required',
    412 => 'Precondition Failed',
    413 => 'Request Entity Too Large',
    414 => 'Request-URI Too Large',
    415 => 'Unsupported Media Type',
    416 => 'Request Range Not Satisfiable',
    417 => 'Expectation Failed',
    422 => 'Unprocessable Entity',            # WebDAV
    423 => 'Locked',                          # WebDAV
    424 => 'Failed Dependency',               # WebDAV
    500 => 'Internal Server Error',
    501 => 'Not Implemented',
    502 => 'Bad Gateway',
    503 => 'Service Unavailable',
    504 => 'Gateway Timeout',
    505 => 'HTTP Version Not Supported',
    507 => 'Insufficient Storage',            # WebDAV
);

#####################################################################
# Called by Stream.pm when there is some pending data in inbuffer
sub read_data
{
    my ($self) = @_;

    if (length($self->{inbuffer}) > 1000000)
    {
	$self->send_error(413); # REQUEST_ENTITY_TOO_LARGE
	$self->{inbuffer} = undef;
	return;
    }
    
    # We may or may not have a whole request here. 
    # Cant tell until we parse all the headers and maybe get 
    # any trailing content.
    my $buf = $self->{inbuffer};

    return unless $buf =~ /\015?\012\015?\012/; # Have at least a header
    
    if ($buf !~ s/^(\S+)[ \t]+(\S+)(?:[ \t]+(HTTP\/\d+\.\d+))?[^\012]*\012//) 
    {
	$self->send_error(400);  # BAD_REQUEST
	$self->{inbuffer} = undef;
	return;
    }
    
    my $r = Radius::HTTPRequest->new
	('method' => $1,
	 'uri'    => $2,
	 'proto'  => $3);
    
    %{$r->{headers}} = Radius::HTTPRequest::parse_header(\$buf);

    my $len = $r->header('Content-Length');
    if ($len)
    {
	return if $len > length($buf); # Need more content
	$r->{content} = $buf;
    }
    
    $self->handle_request($r);
    $self->{inbuffer} = undef;
}

#####################################################################
# Push log messages from Stream up to the parent
sub log
{
    my ($self, @args) = @_;
    $self->{parent}->log(@args);
}

#####################################################################
sub send_basic
{
    my ($self, $code, $content, %headers) = @_;

    my $status = $StatusCode{$code};
    $headers{Date} = CGI::Util::expires('now') unless exists $headers{Date};
    $headers{Server} = $main::ident unless exists $headers{Server};
    $headers{'Content-Type'} = 'text/html' unless exists $headers{'Content-Type'};
    $headers{'Content-Length'} = defined $content ? length($content) : 0
        unless exists $headers{'Content-Length'};

    my $headers;
    foreach (keys %headers)
    {
	$headers .= $_ . ': ' . $headers{$_} . $CRLF;
    }
    $self->write("HTTP/1.1 $code $status${CRLF}" . $headers . $CRLF . $content);
}

#####################################################################
# Send a simple error indication, with optional error message
sub send_error
{
    my ($self, $code, $error) = @_;

    my $status = $StatusCode{$code};
    my $content = "<title>$code $status</title>
<h1>$code $status</h1>
$error
";
    $self->send_basic($code, $content);
}

#####################################################################
sub send_redirect
{
    my ($self, $loc, @headers) = @_;

    $self->send_basic(307, undef, Location => $loc, @headers);
}

#####################################################################
# Called when a complete request has been received
# Parse and process it
sub handle_request
{
    my ($self, $r) = @_;

    $self->log($main::LOG_DEBUG,  "ServerHTTP Connection $r->{method} $r->{uri}");

    $r->parse_params()
	if ($r->{method} eq 'POST');
    $r->parse_keywords()
	if ($r->{method} eq 'GET');

    # Look for pages and actions we can handle internally
    if ($r->{uri} =~ /^\/login/)
    {
	return $self->handle_login($r);
    }
    elsif (exists $Radius::ServerHTTP::Connection::hardwired{$r->{uri}})
    {
	# Hardwired file whose contents we keep internally
	# Dont need authenticaiton for these
	# REVIST: Check for If-Modified-Since
	if (exists $r->{headers}->{'if-modified-since'})
	{
	    return $self->send_error(304)  # Not Modified
		if &Radius::Util::parseDateRFC1123
		    ($r->{headers}->{'if-modified-since'}[0])
		    >= $main::statistics{start_time};
	}

	# Work out the content type. We only handle a small subset
	my $content_type = 'text/html';
	$content_type = 'application/x-javascript' if $r->{uri} =~ /\.js$/i;
	$content_type = 'text/css'                 if $r->{uri} =~ /\.css$/i;
	$content_type = 'image/gif'                if $r->{uri} =~ /\.gif$/i;
	return $self->send_ok($Radius::ServerHTTP::Connection::hardwired{$r->{uri}},
			      'Content-Type' => $content_type,
			      'Last-Modified' => CGI::Util::expires
			          ($main::statistics{start_time}));
    }
    elsif (!($self->{session} = $self->check_cookie($r)))
    {
	return $self->send_redirect('/login');
    }
    elsif ($r->{uri} =~ /^\/logout/)
    {
	return $self->handle_logout($r);
    }
    elsif ($r->{uri} =~ /^\/configuration\/manual/)
    {
	return $self->no_privilege() 
	    unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_EDIT);
	return $self->handle_configuration_manual($r);
    }
    elsif ($r->{uri} =~ /^\/configuration\/keys/)
    {
	return $self->no_privilege() 
	    unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_EDIT);
	return $self->handle_configuration_keys($r);
    }
    elsif ($r->{uri} =~ /^\/configuration\/save/)
    {
	return $self->no_privilege() 
	    unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_SAVE);
	return $self->handle_configuration_save($r);
    }
    elsif ($r->{uri} =~ /^\/configuration\/edit/)
    {
	return $self->no_privilege() 
	    unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_EDIT);
	return $self->handle_configuration_edit($r);
    }
    elsif ($r->{uri} =~ /^\/configuration\/upload/)
    {
	return $self->no_privilege() 
	    unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_EDIT);
	return $self->handle_configuration_upload($r);
    }
    elsif ($r->{uri} =~ /^\/log/)
    {
	return $self->no_privilege() 
	    unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_STATUS);
	return $self->handle_log($r);
    }
    elsif ($r->{uri} =~ /^\/perl/)
    {
	return $self->no_privilege() 
	    unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_STATUS);
	return $self->handle_perl($r);
    }
    elsif ($r->{uri} =~ /^\/system/)
    {
	return $self->no_privilege() 
	    unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_STATUS);
	return $self->handle_system($r);
    }
    elsif ($r->{uri} =~ /^\/statistics/)
    {
	return $self->no_privilege() 
	    unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_STATUS);
	return $self->handle_statistics($r);
    }
    elsif ($r->{uri} =~ /^\/modules/)
    {
	return $self->no_privilege() 
	    unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_STATUS);
	return $self->handle_modules($r);
    }
    elsif ($r->{uri} =~ /^\/status/)
    {
	return $self->no_privilege() 
	    unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_STATUS);
	return $self->handle_status($r);
    }
    elsif ($r->{uri} =~ /^\/reset/)
    {
	return $self->no_privilege() 
	    unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_RESET);
	return $self->handle_reset($r);
    }
    elsif ($r->{uri} =~ /^\/license/)
    {
	return $self->handle_license($r);
    }
    elsif ($r->{uri} =~ /^\/support/)
    {
	return $self->handle_support($r);
    }
    elsif ($r->{uri} =~ /^\/$/)
    {
	return $self->handle_root($r);
    }
    else
    {
	if (defined $self->{parent}->{PageNotFoundHook})
	{
	    # Returns code, contents, @headers
	    my (@result) = $self->{parent}->runHook
		('PageNotFoundHook', undef, $r->{uri}, \$self);
	    return $self->send_basic(@result) if @result;
	}
	return $self->send_error(404);  # NOT_FOUND
    }
}

#####################################################################
sub handle_login
{
    my ($self, $r) = @_;

    my $username = $r->param('username');
    my $password = $r->param('password');

    return $self->show_login()
	unless defined $username;

    my $priv_level = $self->authenticate($username, $password);
    return $self->show_login('<font color="red">Bad username or password</font>')
	unless $priv_level;

    # Username/password is good:
    # Set up a cookie that check_cookie can verify later
    # Domain defaults to the host name of the server which generated 
    # the cookie response. 
    my $session = $self->create_session($username, $password, $priv_level);
    my $token = $session->{token};
    my $cookie = "radiator-login-token=$token;Path=/;Expires=" 
	. CGI::Util::expires("+$self->{SessionTimeout}s", 'cookie');
    $self->{session} = $session;

    # Show the root page
    # This redirect causes warning dialogs on Firefox:
    return $self->handle_root($r, 'Set-Cookie' => $cookie);
}

#####################################################################
sub handle_logout
{
    my ($self, $r) = @_;

    $self->destroy_session($self->{session});
    $self->{session} = undef;
    return $self->send_redirect('/login');
}

#####################################################################
# Create and save a new session context for this user
sub create_session
{
    my ($self, $username, $password, $priv_level) = @_;

    my $host = $self->{Host};
    my $token = Digest::MD5::md5_hex("$username:$password:$host");

    my $context = Radius::Context::get("SessionHTTP:$token", $self->{SessionTimeout});
    $context->{username} = $username;
    $context->{password} = $password;
    $context->{host} = $host;
    $context->{created} = $context->{last_used} = time;
    $context->{token} = $token;
    $context->{priv_level} = $priv_level;

    return $context;
}

#####################################################################
# Verify that the session specified by the token is valid for this user. 
# If so, return the session context
sub verify_session
{
    my ($self, $token) = @_;

    my $context = Radius::Context::find("SessionHTTP:$token");
    return unless $context;

    return unless $context->{host} eq $self->{Host};
    $context->{last_used} = time;
    return $context;
}

#####################################################################
# Verify that the session specified by the token is valid for this user. 
# If so, return the session context
sub destroy_session
{
    my ($self, $session) = @_;

    my $token = $session->{token};
    return Radius::Context::destroy("SessionHTTP:$token");
}

#####################################################################
sub handle_root
{
    my ($self, $r, @headers) = @_;


    # Display the root page
    $self->send_standard(<<"EOF",
Welcome to Radiator RADIUS Server from 
<a href="http://www.open.com.au">Open System Consultants</a>. 
Using this web interface you can monitor, 
control and configure this Radiator. <br>
Links down the left hand side provide access
to the most important pages.
<p>
The <b>Administration</b> pages allow you to inspect the current state of the server, 
view log files and other major functions.
<p>
The <b>Configuration</b> pages allow you to view and change the currently running 
Radiator configuration. Simple and advanced interfaces are provided.
<p>
The <b>Miscellaneous</b> pages provide access to various licensing and support 
related pages. 
<p>

The <b>Advanced</b> pages provide advanced functions such as manual editing of the current configuration file and restarting the server.
<p>

For more information about understanding, installing and configuring Radiator, see the
<a href="$refmanual">Radiator Reference Manual</a> online.

EOF
			 @headers);
}

#####################################################################
sub handle_license
{
    my ($self, $r) = @_;


    # Display the license 
    $self->send_standard("This page displays the license for your copy of Radiator<p><pre>\n" .  CGI::Util::simple_escape($Radius::Documentation::license) . '</pre>');
}

#####################################################################
sub handle_support
{
    my ($self, $r) = @_;


    # Display the suport page
    $self->send_standard(<<'EOF'
A wide range of support options are available for Radiator from 
<a href="http://www.open.com.au">Open System Consultants (OSC)</a>. 
For details on what 
level of support has been purchased by your organisation, contact your local 
administration or purchasing staff, or email
<a href="mailto:admin@open.com.au">admin@open.com.au</a>

<h3>Email support</h3>
For a guaranteed, private response from OSC technical staff, 
your organisation should purchase an email support contract. 
Email support contracts last for a fixed period (typically a year), and entitle you to 
a prompt answer by email to questions you may pose, up to a fixed limit on 
OSC staff time.
<p>
If you have an Email support contract and require support, email to 
<a href="mailto:radius-support@open.com.au?subject=UserID:youruserid:your topic for discussion">Radiator Email Support Alias</a>

<p>All email sent to the email support alias <b>MUST</b> include your
Email Support Username (<b>UserID</b>) in the Subject line, something
like this:

<p>Subject: <b>UserID</b>:xyzzy: your topic for discussion here <br>
<i>(where xyzzy is your Email Support Username)</i>.

<p>Your Email Support Username is sent to you by email when you purchase
your email support contract. If you are unable to determine your Email
Support Username, contact <a href="mailto:info@open.com.au">info@open.com.au</a>.
(Please include your company name and, if possible, the person who originally
purchased your Email support or software).

<p>Email sent to an email support address that does not include the Email
Support Username <i><b>will not</b></i> be answered. Instead you will
receive an automatic request to resubmit your email with your Email Support
Username in the Subject line.
<p>
Be sure to provide as much detail about your problem as possible, 
including Trace 4 log files and your Radiator configuration file (no secrets please).

<h3>Phone Support</h3>
OSC offers a range of telephone support options up to 24 x 7 telephone support.
For a quotation please contact <a href="mailto:info@open.com.au">info@open.com.au</a>.
<p>
If you have a telephone support contract, then you will have already been 
provided with the support number to call.

<h3>Consulting, installation and training services</h3>
Open System Consultants can provide installation, configuration, customisation, advice,
and training for Radiator and other OSC products. Our highly skilled
consultants can provide these services either remotely or on-site.
<p>For more details and an estimate, email your requirements to 
<a href="mailto:info@open.com.au">info@open.com.au</a>.

<h3>Radiator mailing list</h3>
If you have no support contract, you can use the free Radiator mailing list.
The free list is a very active, community supported list where members 
of the Radiator community 
offer helpful advice to other members. 
Open System Consultants staff occasionally monitor the list too,
but there is no guarantee of a response from OSC staff (or anyone else for that matter)
<p>
To use the free list, first subscribe by sending email with the single 
word "subscribe" in the body (not in the subject line) to 
<a href="mailto:radiator-request@open.com.au?subject=subscribe&body=subscribe">radiator-request@open.com.au</a>. 
After that you can post questions 
to the list by emailing to 
<a href="mailto:radiator@open.com.au">radiator@open.com.au</a>.
Be sure to provide as much detail about your problem as possible, 
including Trace 4 log files and your Radiator configuration file (no secrets please).
The free mailing list is subject to the 
<a href="http://www.open.com.au/mailistpolicy.html">Mailing List Policy</a>

<h3>More information</h3>
More information about support options and other arrangements can be found at 
<a href="http://www.open.com.au/support.html">OSC Support</a>
EOF
			    );
}

#####################################################################
sub handle_status
{
    my ($self, $r) = @_;

    # Display the status page
    my $start_time = localtime($main::statistics{start_time});
    my $uptime = &Radius::Util::formatInterval(time - $main::statistics{start_time});

    $self->send_standard(<<"EOF"
This page shows the status of this Radiator RADIUS Server, along with the 
most significant statistics.

<table class="status-page">
<tr><th>Server identity</th>
    <td>$main::ident</td></tr>
<tr><th>Configuration file</th>
    <td>$main::config_file</td></tr>
<tr><th>Command line</th>
    <td>@main::original_argv</td></tr>
<tr><th>Start time</th>
    <td>$start_time</td></tr>
<tr><th>Uptime</th>
    <td>$uptime</td></tr>
<tr><th>Total requests</th>
    <td>$main::statistics{total_packets}</td></tr>
<tr><th>Request rate (per sec)</th>
    <td>$main::statistics{packet_rate}</td></tr>
</table>
EOF
			    );
}

#####################################################################
sub handle_reset
{
    my ($self, $r) = @_;

    # Look for actions to perform
    my $message;
    if ($r->{uri} =~ /action=reset/)
    {
	$self->auditTrail("Server Reset by $self->{session}->{username} at $self->{session}->{host}");
	&main::request_reset();
	$message = "Server has been Reset";
	$main::config_changed = undef;
	# Fall through: expect user to refresh login during next session
#	return $self->show_login('/', '<font color="red">Radiator has been reset</font>');
    }
    else
    {
	$message = $main::config_changed ? 
	    '<b>Caution:</b> There are unsaved configuration changes' 
	    : 'There are no unsaved configuration changes' 
    }
    $self->send_standard(<<"EOF"
The <b>Reset Server</b> button will reread the 
configuration file and restart the Radiator server. 
Any unsaved configuration changes will be lost.
<p>
$message
<div id="actions">
<form action="/reset&action=reset">
<input type="submit" value="Reset Server">
</form>
</div>
EOF
			 );
}

#####################################################################
sub handle_configuration_upload
{
    my ($self, $r) = @_;

    # Look for actions to perform
    my $message;
    if ($r->{uri} =~ /action=upload/)
    {
	# Save the new config file to a temp file and parse it
	my $tempfile = File::Temp::tempfile();
	print $tempfile $r->param('configfile');
	seek($tempfile, 0, 0); # Rewind
	
	# Instantiate a new configuration
	$main::config->destroy();
	$main::config = Radius::ServerConfig->new();
	$main::config->parse($tempfile, 'uploaded file');
	$main::config->activate();

	$self->auditTrail("New configuration file uploaded by $self->{session}->{username} at $self->{session}->{host}");
	$message = "Configuration file uploaded and activated";
    }

    $self->send_standard(<<"EOF"
You can upload a new configuration file from your browser and test
it in the server. The new configuration will not be permanently saved until you
save it using the <a href="/configuration/save">Save</a> page.
<p>
$message
<div id="actions">
<form action="/configuration/upload&action=upload" method="post" enctype="multipart/form-data">
<input type="file" name="configfile">
<input type="submit" value="Upload">
</form>
</div>
EOF
			    );
}

#####################################################################
# Display a configuration edit page
# Edit the object whose name is specified with the ibject parameter. 
# Defaults to the root ServerConfig
sub handle_configuration_edit
{
    my ($self, $r) = @_;

    my $action = $r->param('action');
    my $path = $r->param('path');

    if ($action eq 'save')
    {
	# Save the current configuration to the config file
	my $save_error = $self->save_config();
	$self->auditTrail("Save configuration by $self->{session}->{username} at $self->{session}->{host}");
	return $self->handle_error("Could not save configuration: $save_error") 
	    if $save_error;
    }
    elsif ($action eq 'delete')
    {
	# Delete the indicated object from an objectlist
	$self->auditTrail("Delete $path by $self->{session}->{username} at $self->{session}->{host}");
	return $self->handle_delete($r);
    }
    elsif ($action eq 'update')
    {
	# Update the running configuration in memory
	# REVISIT
	my $errors = $self->update_config($path, $r);
	$self->auditTrail("Update $path by $self->{session}->{username} at $self->{session}->{host}");
	return $self->handle_error("Error(s) updating configuration:<p>$errors")
	    if $errors;
    }
    elsif ($action eq 'classselect')
    {
	# First step in creating a new object, selecting the class
	return $self->handle_classselect($r);
    }
    elsif ($action eq 'classselected')
    {
	# Second step in creating a new object, editing the initial params
	return $self->handle_classselected($r);
    }
    elsif ($action eq 'create')
    {
	# Third step in creating a new object, creating the object
	# Then allowing the user to reedit it.
	$self->auditTrail("Create $self->{session}->{username} at $self->{session}->{host}");
	return $self->handle_create($r);
    }
    # Everything else
    return $self->edit_object_page($path, $r);
}

#####################################################################
sub handle_delete
{
    my ($self, $r) = @_;

    my $path = $r->param('path');

    if ($path =~ /(.*)\.(\w+)\.(\d+)$/)
    {
	my $parent  = $1;
	my $keyword = $2;
	my $position = $3;
	
	my $object = findObject($parent);
	return $self->handle_error("Could not find parent object $parent. Perhaps it has been deleted") unless $object;
	return $self->handle_error("Could not find object keyword $keyword in $parent. Perhaps it has been deleted") unless exists $object->{$keyword};
	
	my $target = $object->{$keyword}[$position];
	return $self->handle_error("Could not find object keyword $keyword in $parent at position $position. Perhaps it has been deleted") unless $target;
	$target->destroy();
	splice(@{$object->{$keyword}}, $position, 1); # Remove it
	$main::config_changed++;
	# Get the object name of the parent
	# Now show the edit page of the parent:
	return $self->edit_object_page($parent, $r);
    }
    return $self->handle_error('Could not parse path of object to delete');
}


#####################################################################
# Display a dialog to create a new object
# keyword specifies what class of object (the parents objectlist keyword,
# parent gives the path of the parent object
# position gives the index in the parents array
sub handle_classselect
{
    my ($self, $r) = @_;

    my $path = $r->param('path');

    my $formitems = '';
    my $helpitems = '';
    my ($requirename, $class);
    if ($path =~ /(.*)\.(\w+)\.(\d+)$/)
    {
	my $parentpath = $1;
	my $keyword = $2;
	my $parent = findObject($parentpath);
	my $parentclass = ref($parent);
	my ($options, %options, $message);
	if ($keyword eq 'AuthBy')
	{
	    $message = 'You are creating a new AuthBy. Select the type of authenticator to use:';
	    # Select all the object class names that look like AuthXXXXXXX
	    foreach (keys %Radius::Documentation::objects)
	    {
		$options{$_} = "AuthBy $1" if $_ =~ /^Auth([A-Z0-9_]+)$/;
	    }
	}
	elsif ($keyword eq 'ClientList')
	{
	    $message = 'You are creating a new ClientList. Select the type of ClientList to use:';
	    # Select all the object class names that look like ClientListXXXXXXX
	    foreach (keys %Radius::Documentation::objects)
	    {
		$options{$_} = "ClientList $1" if $_ =~ /^ClientList([A-Z0-9_]+)$/;
	    }
	}
	elsif ($keyword eq 'Log')
	{
	    $message = 'You are creating a new Log. Select the type of log to use:';
	    # Select all the object class names that look like LogXXXXXXX
	    foreach (keys %Radius::Documentation::objects)
	    {
		$options{$_} = "Log $1" if $_ =~ /^Log([A-Z0-9_]+)$/;
	    }
	}
	elsif ($keyword eq 'AuthLog')
	{
	    $message = 'You are creating a new AuthLog. Select the type of logger to use:';
	    # Select all the object class names that look like LogXXXXXXX
	    foreach (keys %Radius::Documentation::objects)
	    {
		$options{$_} = "AuthLog $1" if $_ =~ /^AuthLog([A-Z0-9_]+)$/;
	    }
	}
	elsif ($keyword eq 'Server')
	{
	    $message = 'You are creating a new Server object. Select the type of server to use:';
	    # Select all the object class names that look like ServerXXXXXXX
	    foreach (keys %Radius::Documentation::objects)
	    {
		$options{$_} = "Server $1" if $_ =~ /^Server([A-Z0-9_]+)$/;
	    }
	    $options{Monitor} = 'Monitor';
	}
	elsif ($keyword eq 'AddressAllocator')
	{
	    $message = 'You are creating a new AddressAllocator object. Select the type of allocator to use:';
	    # Select all the object class names that look like ServerXXXXXXX
	    foreach (keys %Radius::Documentation::objects)
	    {
		$options{$_} = "AddressAllocator $1" if $_ =~ /^AddressAllocator([A-Z0-9_]+)$/;
	    }
	}
	elsif ($keyword eq 'SessionDatabase')
	{
	    $message = 'You are creating a new SessionDatabase object. Select the type of database to use:';
	    # Select all the object class names that look like ServerXXXXXXX
	    foreach (keys %Radius::Documentation::objects)
	    {
		$options{$_} = "SessionDatabase $1" if $_ =~ /^Sess([A-Z0-9_]+)$/;
	    }
	}
	elsif ($keyword eq 'StatsLog')
	{
	    $message = 'You are creating a new StatsLog object. Select the type of database to use:';
	    # Select all the object class names that look like ServerXXXXXXX
	    foreach (keys %Radius::Documentation::objects)
	    {
		$options{$_} = "StatsLog $1" if $_ =~ /^StatsLog([A-Z0-9_]+)$/;
	    }
	}
	elsif ($keyword eq 'Handler')
	{
	    $message = "You are creating a new Handler. You must first enter a new, unique Name for it. The Name of a Handler is an expression that selects what requests teh Handler wil be used for. For example <b>Client=clientid</b> of <b>User-Name=specialname</b>";
	    $requirename++;
	    $class = 'Radius::Handler';
	}
	elsif ($keyword eq 'Realm')
	{
	    $message = "You are creating a new Realm. You must first enter a new, unique Name for it. The Name of a Realm is the realm that will be matched in the User-Name of incoming requests.";
	    $requirename++;
	    $class = 'Radius::Realm';
	}
	elsif ($keyword eq 'Client')
	{
	    $message = "You are creating a new Client. You must first enter a new, unique Name for it. the Name of a Client is the DNS name or IP address of the RADIUS client that will match this Client clause.";
	    $requirename++;
	    $class = 'Radius::Client';
	}
	elsif ($keyword eq 'Hosts' && $parentclass eq 'Radius::AuthRADIUS')
	{
	    $message = "You are creating a new Host for AuthBy RADIUS. You must first enter a new, unique Name for it. The Name of a Host is the DNS name or IP address of the remote RADIUS server";
	    $requirename++;
	    $class = 'Radius::Host';
	}
	elsif ($keyword eq 'Hosts' 
	       && ($parentclass eq 'Radius::AuthLOADBALANCE'
		   || $parentclass eq 'Radius::AuthHASHBALANCE'
		   || $parentclass eq 'Radius::AuthVOLUMEBALANCE'
		   || $parentclass eq 'Radius::AuthROUNDROBIN'))
	{
	    $message = "You are creating a new Host for $parentclass. You must first enter a new, unique Name for it. The Name of a Host is the DNS name or IP address of the remote RADIUS server";
	    $requirename++;
	    $class = 'Radius::Host';
	}
	elsif ($keyword eq 'Hosts' && $parentclass eq 'Radius::AuthRADSEC')
	{
	    $message = "You are creating a new Host for AuthBy RADSEC. You must first enter a new, unique Name for it. The Name of a Host is the DNS name or IP address of the remote RADSEC server";
	    $requirename++;
	    $class = 'Radius::RadsecHost';
	}
	elsif ($keyword eq 'Hosts' && $parentclass eq 'Radius::AuthMULTICAST')
	{
	    $message = "You are creating a new Host for AuthBy MULTICAST. You must first enter a new, unique Name for it. The Name of a Host is the DNS name or IP address of the remote RADIUS server";
	    $requirename++;
	    $class = 'Radius::Host';
	}
	elsif ($keyword eq 'AddressPool')
	{
	    $message = "You are creating a new AddressPool for AddressAllocatorSQL.. You must first enter a new, unique Name for it. The Name of an AddressPool is the pool name to be used to identify this pool of addresses";
	    $requirename++;
	    $class = 'Radius::AddressPool';
	}
	elsif ($keyword eq 'Routes')
	{
	    $message = "You are creating a new Route for AuthDNSROAM. You should first enter a new, unique Name for it. ";
	    $requirename++;
	    $class = 'Radius::AuthDNSROAM::Route';
	}
	else
	{
	    return $self->handle_error("Do not know how to make an object for keyword $keyword");
	}

	if ($requirename)
	{
	    $formitems .= qq|<input type="text" name="name" size="40"><input type="hidden" name="class" value="$class">|;
	}
	if (%options)
	{
	    $formitems .= qq|<select name="class" onchange="typeChosen(this);">|;
	    # Make an options list
	    foreach (sort keys %options)
	    {
		$formitems .= qq|<option value="Radius::$_">$options{$_}</option>|;
		if (length $Radius::Documentation::objects{$_})
		{
		    my $help = $Radius::Documentation::objects{$_};
		    $helpitems .= qq|<div id="helpitem_Radius::$_" class="popup">$help</div>\n|;
		}
		
	    }
	    $formitems .= '</select>';
	}
	$self->send_standard(<<"EOF"
$message

<form name="classselectForm" method="post" action="/configuration/edit">
<input type="hidden" name="path" value="$path">
<input type="hidden" name="action" value="classselected">
$formitems
<input type="submit" value="Next">
</form>
<div id="objectTypeHelp">
<p id="objectTypeHelp"></p>
</div>
$helpitems

EOF
				 );
	return;

    }
    return $self->handle_error('Could not parse path of object to select');
}

#####################################################################
sub handle_classselected
{
    my ($self, $r) = @_;

    return $self->handle_create($r);
}

#####################################################################
# Now have the desired object class and maybe a name, so create the instance
# and splice it into the parent objectlist
sub handle_create
{
    my ($self, $r) = @_;

    my $path = $r->param('path');
    my $name = $r->param('name');
    my $class = $r->param('class');

    return $self->create_and_edit($r, $path, $name, $class);
}

#####################################################################
# Instantiate and object and start editing it
sub create_and_edit
{
    my ($self, $r, $path, $name, $class) = @_;

    if ($path =~ /(.*)\.(\w+)\.(\d+)$/)
    {
	my $parentpath = $1;
	my $keyword = $2;
	my $position = $3;
	
	my $parentobj = findObject($parentpath);
	return $self->handle_error("Could not find parent object $parentpath. Perhaps it has been deleted") 
	    unless $parentobj;
	# Caution some classes dont have their own module:
	return $self->handle_error("Could not load module for class $class: $@") 
	    unless $class->can('new') || eval("require $class");
	my $new = $class->new(undef, $name);
	return $self->handle_error("Could not create a new object of class $class") 
	    unless $new;
	splice(@{$parentobj->{$keyword}}, $position, 0, $new);
	return $self->edit_object_page($path, $r);
    }

    return $self->handle_error('Could not parse path of object to create');
}

#####################################################################
# Display the configuration file in a manual editor
sub handle_configuration_manual
{
    my ($self, $r) = @_;

    my $action = $r->param('action');
    if ($action eq 'save')
    {
	# Move the existing file aside
	my $filename = $main::config_file;
	return $self->handle_error("Could not make backup of configuration file $filename: $!")
	    unless Radius::Util::save_backup($filename);

	# Open the file and save it
	return $self->handle_error("Could not open configuration file $filename for writing: $!")
	    unless open(CONFIG, '>', $filename);
	my $config = $r->param('config_file');
	# Translate multiple line ending chars into a single local file endings
	# Since what comes back from the browser may be odd
	$config =~ s/\x0d\x0a/\n/g;
	print CONFIG $config;
	close(CONFIG);
	$self->auditTrail("Manual Edit by $self->{session}->{username} at $self->{session}->{host}");

    }
    # Read the configuration file
    return $self->handle_error("Could not open configuration file $main::config_file for reading: $!")
	unless open(CONFIG, $main::config_file);

    local $/; # Slurp mode
    my $config = <CONFIG>;
    close(CONFIG);

    $self->send_standard(<<"EOF"
Editing configuration file: $main::config_file
<p>
This page allows you to inspect and edit the current Radiator configuration 
file. It is an alternative to the other object editing pages in the 
Configuration section.
Press the <b>Save Manual Edits</b> button to save your edits back to the current configuration file, 
then Reset Server on the <a href="/reset">Reset Server</a> page to make the new 
configuration take effect.

<form name="configManualEditForm" method="post" action="/configuration/manual">
<input type="hidden" name="action" value="save">
<textarea name="config_file" cols="80" rows="20">$config</textarea><br>
<input type="submit" value="Save Manual Edits To Configuration File">
</form>
EOF
			    );

}

#####################################################################
# Save the current config
sub handle_configuration_save
{
    my ($self, $r) = @_;

    my $action = $r->param('action');
    if ($action eq 'save')
    {
	# Save the current configuration to the config file
	my $save_error = $self->save_config();
	return $self->handle_error("Could not save configuration: $save_error") 
	    if $save_error;
	$self->auditTrail("ServerHTTP: Configuration file saved by $self->{session}->{username} at $self->{session}->{host}");
	$main::config_changed = undef;
    }

    my $requires = $main::config_changed ? 'requires' : 'does <b>not</b> require';
    $self->send_standard(<<"EOF"
The Save button saves the currently running configuration to the 
current configuration file at <code>$main::config_file</code>.
<p>
The currently running configuration $requires saving.

<form name="configManualEditForm" method="post" action="/configuration/save">
<input type="hidden" name="action" value="save">
<input type="submit" value="Save">
</form>

EOF
);
}

#####################################################################
# Display the license keys
sub handle_configuration_keys
{
    my ($self, $r) = @_;

    # List of config fields that are required for license keys
    my @fields = qw(LicenseVersion LicenseHostname LicenseMaxRequests LicenseExpires LicenseOwner LicenseVendor LicenseKey);

    if (!$main::requires_key)
    {
	return $self->send_standard(<<"EOF"
This instance of Radiator is fully licensed and does not require 
any license keys.
EOF
			     );
    }

    my $object = $main::config;
    my $action = $r->param('action');
    if ($action eq 'save')
    {
	foreach (@fields)
	{
	    my $value = $r->param("config_$_");
	    if ($value eq '')
	    {
		# Empty value or no value sent, clear it
		$object->clear($_);
	    }
	    else
	    {
		$object->set($_, $value);
	    }
	}
	my $error = &main::validateLicense();
	return $self->handle_error($error)
	    if $error;
	$object->activate();
	$main::config_changed++;
    }

    my ($items, $helpitems, $max_detail_level) = $self->make_edit_items('', 1, @fields);
    my $apply = qq|<input type="submit" value="Apply">| 
	if $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_EDIT);

    $self->send_standard(<<"EOF"
This page allows you to enter or change the license keys for this instance of Radiator.
Without a valid license key, Radiator will not reply to RADIUS requests, 
or may only service a limited number of requests. 
<p>
For license keys, email <a href="mailto:info\@open.com.au">Open System Consultants</a>.
<form name="configurationForm" method="post" action="/configuration/keys">
<input type="hidden" name="action" value="save">
<table class="configuration-page">
$items

</table><br>
$apply
</form>
$helpitems
EOF
			    );

}

#####################################################################
# Display the log ring buffer
sub handle_log
{
    my ($self, $r) = @_;

    my ($log, $i);
    for ($i = $self->{parent}->{log_index} + 1; 
	 $i != $self->{parent}->{log_index};
	 $i = ($i + 1) % $self->{parent}->{LogMaxLines})
    {
	$log .= $self->{parent}->{log}[$i] . "\n" 
	    if defined $self->{parent}->{log}[$i];
    }
    $log = CGI::Util::simple_escape($log);

    $self->send_standard(<<"EOF"
This page shows the last $self->{parent}->{LogMaxLines} log messages recorded by 
this Radiator. It can be useful when checking or debugging your new configuration. 
Only messages that meet the Trace level in ServerHTTP will be logged here. 
You can get more or less detail by changing the trace level in the ServerHTTP 
configuration.

<div id="log-lines">
<pre>
$log
</pre>
</div>
EOF
			    );
}

#####################################################################
# Display information about perl on this host
sub handle_perl
{
    my ($self, $r) = @_;

    $self->send_standard(<<"EOF"
This page show the main details about the version of Perl running this Radiator 
and some details about the host platform and permissions. 
It can be useful during support calls.

<table class="perl-page">
<tr><th>Perl executable</th><td>$^X</td></tr>
<tr><th>Perl Version</th><td>$]</td></tr>
<tr><th>Platform</th><td>$^O</td></tr>
<tr><th>Process ID</th><td>$$</td></tr>
<tr><th>Effective User ID</th><td>$></td></tr>
<tr><th>Effective Group ID</th><td>$)</td></tr>
<tr><th>Real User ID</th><td>$<</td></tr>
<tr><th>Real Group ID</th><td>$(</td></tr>
</table>
EOF
			    ) ;
}

#####################################################################
# Display information about this host
sub handle_system
{
    my ($self, $r) = @_;

    my ($sysname, $nodename, $release, $version, $machine) = POSIX::uname();

    $self->send_standard(<<"EOF"
This page show the main details about host machine that this 
Radiator is running on. It can be useful during support calls.

<table class="system-page">
<tr><th>System type</th><td>$sysname</td></tr>
<tr><th>Node name</th><td>$nodename</td></tr>
<tr><th>Release</th><td>$release</td></tr>
<tr><th>Version</th><td>$version</td></tr>
<tr><th>Machine</th><td>$machine</td></tr>
</table>
EOF
			    ) ;
}

#####################################################################
# Display statistic about this object
sub handle_statistics
{
    my ($self, $r) = @_;

    my $path = $r->param('path');
    my $object = findObject($path);
    return $self->handle_error("Could not find existing object $path. Perhaps it has been deleted") 
	unless $object;
    my $stats;
    foreach (sort keys %Radius::ServerConfig::statistic_names)
    {
	my $name = $Radius::ServerConfig::statistic_names{$_};
	my $value = $object->{Statistics}{$_} + 0;
	$stats .= qq|<tr><th>$name</th><td>$value</td></tr>\n|;
    }
    $self->send_standard(<<"EOF"
This page show statistics of requests handled by this object

<table class="statistics-page">
$stats
</table>
EOF
			    ) ;
}

#####################################################################
# Display information about the Radiator modules in use
sub handle_modules
{
    my ($self, $r) = @_;

    my $table = "<tr><td>main::</td><td>$main::VERSION</td></tr>\n";
    no strict 'refs'; # Allow symbolic refs
    foreach (sort keys %{$main::{'Radius::'}})
    {
	next unless /^\w+::/;
	my $version = ${"Radius::${_}VERSION"};
	next unless defined $version;
	# Strip out any silly RCS Revision keywords
	$version = $1 if $version =~ /Revision: (.*) \$$/;
	$version = '-unknown-' unless length $version;
	$table .= "<tr><td>Radius::$_</td><td>$version</td></tr>\n";
    }
    use strict 'refs';
    $self->send_standard(<<"EOF"
This page shows a list of all currently loaded Radiator Perl modules. 
It can be useful during support calls. The version number 
of each module is derived from the 
VERSION variable at the head of each Radiator module file.

<table id="module=list">
<tr><th>Module name</th><th>Version</th></tr>
$table
</table>
EOF
			    );
}

#####################################################################
# Display an operational error message
sub handle_error
{
    my ($self, $message) = @_;

    $self->log($main::LOG_WARNING,  "ServerHTTP User Error: $message");
    $self->send_standard(<<"EOF"
<h2>Error</h2>
$message
EOF
			    );
}

#####################################################################
# Generate an HTML options menu
sub optionmenu
{
    my ($name, $optionlist, $current) = @_;

    my $options;
    foreach (@$optionlist)
    {
	my $selected = ($current eq $_) ? 'selected' : '';
	$options .= qq|<option value="$_" $selected>$_</option>|;
    }
    return qq|<select name="$name">$options</select>|;
}

#####################################################################
sub edit_object_page
{
    my ($self, $path, $r) = @_;

    # editing an existing object
    my $object = findObject($path);
    return $self->handle_error("Could not find existing object $path. Perhaps it has been deleted") 
	unless $object;
    my $objecttype = ref($object);
    my $objectname = $object->{Name};
    $objectname =~ s/^Realm=// if $objecttype eq 'Radius::Realm';
    $objecttype =~ s/^Radius:://;

    my $detail_level = $self->{session}->{detail_level} = int($r->param('detail'));
    
    my %configKeywords = $object->configKeywords();
    my ($items, $helpitems, $max_detail_level)
	= $self->make_edit_items($path, $self->{session}->{detail_level}, 
				 sort keys %configKeywords);
    my $detail_level_selector;

    if ($detail_level > 0)
    {
	my $newlevel = $detail_level - 1;
	my $newlabel = $detail_level_names[$newlevel];
	$detail_level_selector = "<a href=\"$r->{path}?detail=$newlevel&path=$path\">&lt; Show $newlabel</a>&nbsp&nbsp";
    }
    $detail_level_selector .= "<b>$detail_level_names[$detail_level]</b>";
    if ($detail_level < $max_detail_level)
    {	
	my $newlevel = $detail_level + 1;
	my $newlabel = $detail_level_names[$newlevel];
	$detail_level_selector .= "&nbsp&nbsp<a href=\"$r->{path}?detail=$newlevel&path=$path\">Show $newlabel &gt;</a>";
    }

    my $doc = $Radius::Documentation::objects{$objecttype};
    my $viewstats = qq| <a href="/statistics?path=$path">View Statistics</a>\n|
	if exists $object->{Statistics};

    my $apply = qq|<input type="submit" value="Apply">| 
	if $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_EDIT);
    my $content = <<"EOF";
<form name="configurationForm" method="post" action="/configuration/edit">
<h2>$objecttype $objectname</h2>
$doc
$viewstats
<p>$detail_level_selector
<input type="hidden" name="path" value="$path">
<input type="hidden" name="action" value="update">
<input type="hidden" name="detail" value="$detail_level">
<table class="configuration-page">
$items
</table><br>
$apply
</form>
$helpitems
EOF

    $self->send_standard($content);

}

#####################################################################
# Generate editing elements for the object and the parameters given
sub make_edit_items
{
    my ($self, $path, $detail_level, @params) = @_;

    my ($items, $helpitems);
    my $max_detail_level = 0;
    my $object = findObject($path);
    my $objecttype = ref($object);
    my $helpitemindex = 0;
    my %configKeywords = $object->configKeywords();
    
    foreach (@params)
    {
	# Dont ever show some keywords which are obsolete or unnecessary
	next if $objecttype eq 'Radius::AuthRADIUS' && $_ eq 'Host';
	next if $objecttype eq 'Radius::AuthRADSEC' && $_ eq 'Host';
	next if $objecttype eq 'Radius::ServerConfig' && $_ eq 'AuthBy';

	my $value = $object->{$_};
	my $configtype = $configKeywords{$_};
	# See if its a new type of config spec which includes default and doc
	# Old configKeywords only had an object type, not an array
	if (ref($configtype) eq 'ARRAY')
	{
	    my $doc_level = $configtype->[2];
	    $max_detail_level = $doc_level
		if $doc_level > $max_detail_level;
	    next if $doc_level != $detail_level;
	    $helpitems .= qq|<div id="helpitem_${helpitemindex}_popup" class="popup"><dl class="edithelp"><dt>$_</dt><dd>$configtype->[1]</dd>\n</dl></div>\n|;
	    $configtype = $configtype->[0];
	}

	my $editfield;
	# Handle per-parameter or per-type editing and formatting
	# Lots of hard-coded heuristics here
	if ($_ eq 'Trace')
	{
	    my $options;
	    foreach (0 .. 5)
	    {
		my $selected = ($value == $_) ? 'selected' : '';
		$options .= qq|<option value="$_" $selected>$Radius::Log::priorityToLongString[$_]</option>|;
	    }
	    $editfield = qq|<select name="config_$_">$options</select>|;
	}
	elsif ($_ eq 'EAPType')
	{
	    my ($eaptype, $eapname);
	    my @values = @{$value} if defined $value;
	    my $count = 0;
	    while (($eaptype, $eapname) = each %Radius::EAP::eap_type_to_name)
	    {
		my $checked = (grep {$_ eq $eapname} @values) ? 'checked' : '';
		
		$editfield .= qq|<input type="checkbox" name="config_$_$eaptype" value="1" $checked>$eapname |;
		$editfield .= '<br>' if (++$count % 6) == 0; # Wrapping
	    }
	}
	elsif ($_ eq 'AuthByPolicy')
	{
	    $editfield = optionmenu("config_$_", \@authbypolicies, $value);
	}
	elsif ($_ eq 'Baudrate')
	{
	    $editfield = optionmenu("config_$_", \@baudrates, $value);
	}
	elsif ($_ eq 'Databits')
	{
	    $editfield = optionmenu("config_$_", \@databits, $value);
	}
	elsif ($_ eq 'Parity')
	{
	    $editfield = optionmenu("config_$_", \@parity, $value);
	}
	elsif ($_ eq 'Stopbits')
	{
	    $editfield = optionmenu("config_$_", \@stopbits, $value);
	}
	elsif ($_ eq 'Handshake')
	{
	    $editfield = optionmenu("config_$_", \@handshake, $value);
	}
	elsif ($objecttype eq 'Radius::AuthFIDELIO' && $_ eq 'Protocol')
	{
	    $editfield = optionmenu("config_$_", \@fidelioprotocols, $value);
	}
	elsif ($_ eq 'Protocol' && $objecttype eq 'Radius::AuthDNSROAM::Route')
	{
	    $editfield = optionmenu("config_$_", \@roamprotocols, $value);
	}
	elsif ($_ eq 'Protocol')
	{
	    $editfield = optionmenu("config_$_", \@protocols, $value);
	}
	elsif ($_ eq 'Transport')
	{
	    $editfield = optionmenu("config_$_", \@roamtransports, $value);
	}
	elsif ($_ eq 'EAPTLS_CertificateType'
	       || $_ eq 'TLS_CertificateType')
	{
	    $editfield = optionmenu("config_$_", \@certificatetypes, $value);
	}
	elsif ($_ eq 'Scope')
	{
	    $editfield = optionmenu("config_$_", \@scopes, $value);
	}
	elsif ($_ eq 'SSLVerify')
	{
	    $editfield = optionmenu("config_$_", \@sslverifytypes, $value);
	}
	elsif ($_ eq 'Version')
	{
	    $editfield = optionmenu("config_$_", \@ldapversions, $value);
	}
	elsif ($_ eq 'Deref')
	{
	    $editfield = optionmenu("config_$_", \@dereftypes, $value);
	}
	elsif ($_ eq 'SASLMechanism')
	{
	    $editfield = optionmenu("config_$_", \@saslmechanisms, $value);
	}
	elsif ($_ eq 'DBType')
	{
	    $editfield = optionmenu("config_$_", \@dbtypes, $value);
	}
	elsif ($_ eq 'AuthMode')
	{
	    $editfield = optionmenu("config_$_", \@authmodes, $value);
	}
	elsif ($_ eq 'DefaultResult'
	       || $_ eq 'AuthResult'
	       || $_ eq 'AcctResult'
	       || $_ eq 'AcctStartResult'
	       || $_ eq 'AcctStopResult'
	       || $_ eq 'AcctAliveResult'
	       || $_ eq 'AcctOtherResult')
	{
	    $editfield = optionmenu("config_$_", \@resultcodes, $value);
	}
	elsif ($_ eq 'LogSock')
	{
	    $editfield = optionmenu("config_$_", \@syslogsocktypes, $value);
	}
	elsif ($_ eq 'Policy')
	{
	    if ($objecttype eq 'Radius::AuthRSAMOBILE')
	    {
		$editfield = optionmenu("config_$_", \@rsamobilepolicies, $value);
	    }
	    else
	    {
		$editfield = optionmenu("config_$_", \@rsaampolicies, $value);
	    }
	}
	elsif ($_ eq 'SOAPTrace')
	{
	    $editfield = optionmenu("config_$_", \@soaptrace, $value);
	}
	elsif ($_ eq 'AuthType')
	{
	    $editfield = optionmenu("config_$_", \@tacacsauthtypes, $value);
	}
	elsif ($_ eq 'UrlMethod')
	{
	    $editfield = optionmenu("config_$_", \@urlmethods, $value);
	}
	elsif ($_ eq 'PasswordEncryption')
	{
	    $editfield = optionmenu("config_$_", \@urlpasswordencryptions, $value);
	}
	elsif ($_ eq 'NasType')
	{
	    $editfield = optionmenu("config_$_", \@nastypes, $value);
	}
	elsif ($_ eq 'Description')
	{
	    my $escvalue = $value;
	    $escvalue =~ s/\\n/\n/g;
	    $escvalue = CGI::Util::simple_escape($escvalue);
	    $editfield = qq|<textarea name="config_$_" cols="40" rows="3">$escvalue</textarea>|;
	}
	elsif ($configtype eq 'flag')
	{
	    my $checked = $value ? 'checked' : '';
	    $editfield = qq|<input type="checkbox" name="config_$_" value="1" $checked>|;
	}
	elsif ($configtype eq 'string')
	{
	    my $escvalue = CGI::Util::simple_escape($value);
	    $editfield = qq|<input type="text" name="config_$_" value="$escvalue" size="40">|;
	}
	elsif ($configtype eq 'integer')
	{
	    $editfield = qq|<input type="text" name="config_$_" value="$value" size="10">|;
	}
	elsif ($configtype eq 'objectlist')
	{
	    my $keyword = $_;
	    my $index = 0;
	    my $objectpath;
	    foreach (@{$value})
	    {
		$objectpath = $path . '.' . $keyword . '.' . $index;
		my $typename = ref($_);
		$typename =~ s/Radius:://;
		my $easyname = $_->{Name} || $typename;
		$easyname =~ s/^Realm=//;

		$editfield .= qq|<a href="/configuration/edit?path=$objectpath">$easyname</a> <font size="-2"><a href="/configuration/edit?action=delete&path=$objectpath">(delete)</a></font><br>|;
		$index++;
	    }
	    my $newpath = $path . '.' . $keyword . '.' . $index;
	    $editfield .= qq|<font size="-2"><a href="/configuration/edit?action=classselect&path=$newpath">(New...)</a></font>|;
	}
	elsif ($configtype eq 'hook')
	{
	    # Make a feeble attempt to format, because reading from a config file
	    # with slashes at the end of each line makes a single line hook
	    $editfield = qq|<textarea name="config_$_" cols="100" rows="3">$value</textarea>|;
	}
	elsif ($configtype eq 'stringarray' || $configtype eq 'splitstringarray')
	{
	    my $svalue = join("\n", @{$value})  if defined $value;
	    $editfield = qq|<textarea name="config_$_" cols="40" rows="3">$svalue</textarea>|;
	}
	elsif ($configtype eq 'stringhash')
	{
	    my $svalue;
	    foreach (sort keys %{$value})
	    {
		$svalue .= "$_,${$value}{$_}\n";
	    }
	    $editfield = qq|<textarea name="config_$_" cols="40" rows="3">$svalue</textarea>|;
	}
	elsif ($configtype eq 'splitstringhash')
	{
	    my $svalue;
	    foreach (sort keys %{$value})
	    {
		$svalue .= "$_," . join(',', @{$$value{$_}}) . "\n";
	    }
	    $editfield = qq|<textarea name="config_$_" cols="40" rows="3">$svalue</textarea>|;
	}

	elsif ($configtype eq 'counthash')
	{
	    my $svalue = join (' ', keys %{$value});
	    $editfield = qq|<input type="text" name="config_$_" value="$svalue" size="40">|;
	}
	else
	{
	    $editfield = $value;
	}
	$items .= qq|<tr><td valign="top"><a href="$refmanual" id="helpitem_$helpitemindex" onmouseover="popup('helpitem_$helpitemindex', '');return true">$_</a></td><td>$editfield</td></tr>\n|;

	$helpitemindex++;
	
    }
    return ($items, $helpitems, $max_detail_level);
}

#####################################################################
# Returns the users session context if their cookie is still valid
sub check_cookie
{
    my ($self, $r) = @_;

    # Look for our cookie and verify it
    foreach (split(/;\s*/, $r->{headers}->{cookie}[0]))
    {
	if (/^radiator-login-token=(.*)/)
	{
	    # Caution there could be a cookie sent from a previous session, but now
	    # no passwords are required
	    my $session = $self->verify_session($1);
	    return $session if $session;
	}
    }

    # No valid cookie. Do they really need a password?
    # If not make an anonymous session
    return $self->create_session('anonymous', undef, $self->{parent}{DefaultPrivilegeLevel})
	unless defined $self->{parent}{AuthBy} || defined $self->{parent}{Username};

    # No valid cookie, require a username and password to get further
    return;
}

#####################################################################
# Display a login page
sub show_login
{
    my ($self, $message) = @_;

    $self->send_standard(<<"EOF"
<form name="loginForm" method="post" action="/login">
<table class="login-form" cellspacing=0 cellpadding=0>
<tr><td colspan=2>$message</td></tr>
<tr><td colspan=2>Log in to access Radiator.</td></tr>
<tr><td>Username:</td>
    <td><input type="text" tabindex="1" name="username" value="" size="16"></td></tr>
<tr><td>Password:</td>
    <td><input type="password" tabindex="2" name="password" size="16"></td></tr>

<tr><td>&nbsp;</td><td><input type="submit" tabindex="3" value="Login"></td></tr>
</table>
</form>
EOF
			    );
}

#####################################################################
sub template
{
    my ($template, %values) = @_;

    $template =~ s/@@(\w+)/$values{$1}/g;
    return $template;
}

#####################################################################
# Send an OK reply and some content
sub send_ok
{
    my ($self, $content, @headers) = @_;

    $self->send_basic(200, $content, @headers);
}

#####################################################################
# Display a standard template with the logged in message
sub send_standard
{
    my ($self, $content, @headers) = @_;

    my ($logout, $who, $left_menu);
    if ($self->{session})
    {
	$who = "Logged in as: $self->{session}->{username} (privilege level $self->{session}->{priv_level}).";
	my ($admin_menu, $configuration_menu, $miscellaneous_menu, $advanced_menu);
	$admin_menu = qq|<a href="/status">Server status</a><br>|
	    if $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_STATUS);
	$admin_menu .= qq|<a href="/log">View log</a><br>| 
	    if $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_STATUS);
	$admin_menu .= qq|<a href="/logout">Logout</a>| 
	    if $self->{session}->{username} ne 'anonymous';
	$configuration_menu = qq|<a href="/configuration/edit">Edit</a><br>
	    <a href="/configuration/upload">Load config file</a><br>| 
	    if $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_EDIT);

	$configuration_menu .= qq|<a href="/configuration/keys">License keys</a><br>|
	    if $main::requires_key
	    && $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_EDIT);
	$configuration_menu .= qq|<a href="/configuration/save">Save</a><br>|
	    if $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_SAVE);
	
	$miscellaneous_menu = qq|<a href="/license">License</a><br>
	    <a href="/support">Support</a><br>\n|;
	$miscellaneous_menu .= qq|<a href="/system">System</a><br>
	    <a href="/perl">Perl</a><br>
	    <a href="/modules">Modules</a><br>| 
	    if $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_STATUS);
	$advanced_menu = qq|<a href="/configuration/manual">Manual edit</a><br>|
	    if $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_SAVE);
       $advanced_menu .= qq|<a href="/reset">Reset server</a><br>| 
	   if $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_RESET);

	$left_menu = <<"EOF";
     <div id="navigation-content">
      Administration<br>
      <div id="navigation-sub-content">
       $admin_menu
      </div>
      Configuration<br>
      <div id="navigation-sub-content">
       $configuration_menu
      </div>
      Miscellaneous<br>
      <div id="navigation-sub-content">
       $miscellaneous_menu
      </div>
      Advanced<br>
      <div id="navigation-sub-content">
       $advanced_menu
      </div>
     </div>
EOF
    }
    else
    {
	$who = 'Not logged in';
    }

    return $self->send_ok
	(template
	 ($Radius::ServerHTTP::Connection::layout,
	  'main_content' => $content,
	  'status'       => $main::ident . '. ' . $who,
	  'left_menu'    => $left_menu), 
	 @headers);
				   
}

#####################################################################
sub configKeywords
{
    return;
}

#####################################################################
# Check the username and password are correct, if so
# permit further actions
sub authenticate
{
    my ($self, $username, $password) = @_;

    my $auth_ok;

    # Fake up a radius packet we can pass to the AuthBys
    my ($local_port, $local_addr) = Radius::Util::unpack_sockaddr_in(getsockname($self->{socket}));
    my $p =  new Radius::Radius $main::dictionary;
    $p->{rp} = new Radius::Radius $main::dictionary;
    $p->addAttrByNum($Radius::Radius::USER_NAME, $username);
    $p->addAttrByNum($Radius::Radius::USER_PASSWORD, '**obscured**');
    $p->{OriginalUserName} = $username;
    $p->addAttrByNum($Radius::Radius::NAS_IP_ADDRESS, Radius::Util::inet_ntop($local_addr));
    $p->addAttrByNum($Radius::Radius::CALLING_STATION_ID, $self->{Host});
    $p->set_code('Access-Request');
    # Plaintext password, fake the decoded password
    $p->{DecodedPassword} = $password;

    # Add arbitrary data to every request
    $p->parse(&Radius::Util::format_special($self->{AddToRequest}))
	if (defined $self->{AddToRequest});

    # Dump the fake radius request
    &main::log($main::LOG_DEBUG, "ServerHTTP Radius request packet dump:\n" . $p->dump)
	if (&main::willLog($main::LOG_DEBUG, $self->{parent}));

    # First check the authenticators in the AuthBy list
    # Try all the authenticators in sequence until the AuthByPolicy
    # is satisfied
    # CAUTION: The handler might fork
    my ($handler, $reason, $handled);

    foreach $handler (@{$self->{parent}{AuthBy}})
    {
	# Make sure the authby is updated with stats
	push(@{$p->{StatsTrail}}, \%{$handler->{Statistics}});

	($handled, $reason) = $handler->handle_request($p);

	# Evaluate the AuthByPolicy
	last unless $self->{parent}->evaluatePolicy($self->{parent}{AuthByPolicy}, $handled);
    }
    my $priv_level = $Radius::ServerHTTP::PRIV_LEVEL_NONE; # No priv
    if (defined $handled)
    {
	if ($handled == $main::ACCEPT)
	{
	    $priv_level = $p->{rp}->get_attr('Management-Policy-Id');
	    $priv_level = $self->{parent}{DefaultPrivilegeLevel} 
	        unless defined $priv_level
	}
	if ($handled != $main::IGNORE)
	{
	    $p->addAttrByNum($Radius::Radius::SERVICE_TYPE, "HTTP-User-".$priv_level);
	    $self->authlog($handled, $reason, $p);
	    return $priv_level;
	}
    }

    # Did not pass any of the AuthBy, try the hardwired Username
    # as a last resort
    if ($username eq $self->{parent}{Username}
	&& $self->check_plain_password($username, $password, $self->{parent}{Password}))
    {
	$priv_level = $self->{parent}{DefaultPrivilegeLevel};
	$p->addAttrByNum($Radius::Radius::SERVICE_TYPE, "HTTP-User-".$priv_level);
	$self->authlog($main::ACCEPT, $reason, $p);
    }
    else
    {
	$p->addAttrByNum($Radius::Radius::SERVICE_TYPE, "HTTP-User-".$priv_level);
	$self->authlog($main::REJECT, $reason, $p);
    }
    return $priv_level;
}

#####################################################################
# Log auth success/failure to all AuthLog modules
# Args are $s, $r, $p
# $s is the result code
# $r is the reason message
# $p is the current packet
sub authlog
{
    my ($self, @args) = @_;

    map {$_->authlog(@args)} @{$self->{parent}->{AuthLog}}; 
}

#####################################################################
# Test whether the logged in user has the required privilege
sub has_privilege
{
    my ($self, $priv_level) = @_;

#    return (exists $self->{session} && $priv_level <= $self->{session}->{priv_level});
    # Its a bitmask
    return (exists $self->{session} && 
	    ($priv_level & $self->{session}->{priv_level}) == $priv_level);
}

#####################################################################
# Send a simple error indication, with optional error message
sub no_privilege
{
    my ($self) = @_;
    $self->handle_error('You do not have sufficient privileges to do that');
}

#####################################################################
# Find and return a Radiator internal object, given its name
# Names start with . which means the root object of the
# Radiator object tree (ie The ServerConfig at $main::config)
# Path elements are . separated. Each path element is either the
# name of an attribtue, or an integer index into an object array
# eg .Client.0.AuthBy.2
# is the third AuthBy object in the first Client in ServerConfig
sub  findObject
{
    my ($path) = @_;

    my @path = split(/\./, $path);
    my $o = $main::config; # base of the search

    foreach (@path)
    {
	my $pathel = $_;
	next if $pathel eq '';
	my $type = ref($o);
	if ($type =~ /^Radius::/)
	{
	    # Its a Radiator object
	    # Next element of the path should be the name of an attribute
	    $o = $o->{$pathel};
	}
	elsif ($type eq 'ARRAY')
	{
	    # Its an array ref, presumably of object addresses
	    $o = $$o[$pathel];
	}
	else 
	{
	    # huh?
	    return ;
	}
    }
    return $o;
}

#####################################################################
# Optionally save a message to the AuditTrail file
sub auditTrail
{
    my ($self, $line) = @_;

    &Radius::Util::append(&Radius::Util::format_special($self->{parent}->{AuditTrail}), scalar localtime(time) . ': ' . $line . "\n")
	if (defined $self->{parent}->{AuditTrail});
    $self->log($main::LOG_INFO, 'ServerHTTP: ' . $line);
}

#####################################################################
sub save_config
{
    my ($self) = @_;

    my $filename = $main::config->{configFilename};
    return "Could not make backup of configuration file $filename: $!"
	unless Radius::Util::save_backup($filename);

    return "Could not open file $filename for writing: $!"
	unless open(SAVEFILE, '>', $filename);

    my $date = localtime(time);

    print SAVEFILE <<"EOF";
# $filename
#
# Radiator configuration file
# Automatically generated by ServerHTTP
# logged in as $self->{session}->{username}
# from client $self->{Host}:$self->{Port}
# on $date
#
EOF

    # Recursively descend through the config, 
    # saving each object to a file as we go
    $main::config->save_config(*SAVEFILE);
    close(SAVEFILE);
    return;
}

#####################################################################
# Update the running configuration from the fields in the form
# This is longwinded, because some form elements (such as checkbox when turned off) 
# dont always send a value. So we need to find all the attributes that should be 
# on the form and see if we have a value for each one
sub update_config
{
    my ($self, $path, $r) = @_;

    return $self->no_privilege() 
	unless $self->has_privilege($Radius::ServerHTTP::PRIV_LEVEL_EDIT);
    my $object = findObject($path);
    return $self->handle_error("Could not find object $path. Perhaps it has been deleted") 
	unless $object;

    my ($fieldname, $errors);
    my %configKeywords = $object->configKeywords();
    my $detail_level = $self->{session}->{detail_level} = int($r->param('detail'));
    foreach (sort keys %configKeywords)
    {
	# $_ is the keyword
	my $configtype = $configKeywords{$_};
	# See if its a new type of config spec which includes default and doc
	# Old configKeywords only had an object type, not an array
	if (ref($configtype) eq 'ARRAY')
	{
	    my $doc_level = $configtype->[2];
	    next if $doc_level != $detail_level;
	    $configtype = $configtype->[0];
	}

	# These never appear in an edit update
	next if $configtype eq 'objectlist';

	$object->clear($_);

	if ($_ eq 'EAPType')
	{
	    my ($eaptype, $eapname);
	    while (($eaptype, $eapname) = each %Radius::EAP::eap_type_to_name)
	    {
		$object->set('EAPType', $eapname)
		    if $r->param("config_$_$eaptype");
	    }
	}
	elsif (   $configtype eq 'stringarray' 
	       || $configtype eq 'splitstringarray'
	       || $configtype eq 'stringhash'
	       || $configtype eq 'splitstringhash')
	{
	    # Need to split the textarea into separate lines
	    my $param = $_;
	    map $object->set($param, $_), split(/\n/, $r->param("config_$_"));
	}
	else
	{
	    my $value = $r->param("config_$_");
	    $value =~ s/\r\n/\\n/g if $_ eq 'Description';
	    next if $value eq '';

	    $@ = undef;
	    $object->set($_, $value);
	    if ($@)
	    {
		# Hook compile error?
		$errors .= "Error setting $_: $@<br>";
	    }
	}
    }
    $object->activate(); # Make the changes take effect
    $main::config_changed++;
    return $errors;
}

# Basic layout for all pages
$Radius::ServerHTTP::Connection::layout = <<'EOF';
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>
 <title>Radiator RADIUS Server</title>
 <script type="text/javascript" src="/js/init.js"></script>
 <script type="text/javascript" src="/js/browser.js"></script>
 <script type="text/javascript" src="/js/utils.js"></script>
 <script type="text/javascript" src="/js/mouseovers.js"></script>

 <style type="text/css" media="screen">
  @import url('/radiator.css');
 </style>
</head>

<body class="left-sidebar">
 <div id="page">
  <div id="header">
   <div id="logo-title">
    <table class="logo-title" width="100%">
     <tr>
      <td width=20px>
       <div id="logo">
        <a href="http://www.open.com.au/radiator" title="Home" rel="home">
         <img src="/images/Radiator2.gif" alt="Home" id="logo" />
        </a>
       </div>
      </td>
      <td>
       <div id="site-slogan">
        Radiator RADIUS Server
       </div>
      </td>
     </tr>
    </table> <!-- logo-title -->
   </div> <!-- /logo-title -->
   <div id=status-bar>
     @@status
   </div> <!-- /status-bar -->
  </div> <!-- /header -->
  <table class="main-page" width="100%">
   <tr id="navigation">
    <td width=150px valign=top>
    @@left_menu
    </td>
    <td valign=top>
     <div id="main-content">
     @@main_content
     </div>
    </td>
   </tr>
  </table>
 </div> <!-- /page -->

@@trailing_content
</body>

</html>
EOF


$Radius::ServerHTTP::Connection::hardwired{'/images/Radiator2.gif'} 
    = MIME::Base64::decode_base64(<<'EOF'
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
6keSSqkVYJiV6qCjyaiQaqhM+QeBAAA7
EOF
);



$Radius::ServerHTTP::Connection::hardwired{'/radiator.css'} = <<'EOF';
body {font-family:Verdana,Arial,Helvetica,sans-serif;color:#111;line-height:1.5em}
body.left-sidebar{min-width:600px;background:#D7E3F0}
#page textarea{font-family:Verdana,Arial,Helvetica,sans-serif;color:#111;line-height:1.5em}
#logo-title{margin:0;position:relative;}
#status-bar{background:#2763A5;color:#ccc}
#site-slogan{text-align:right;color:#104199;margin:0;font-size:125%;margin-right:20px;}
#navigation-header{font-size:125%;color:#104199;}
#navigation-content{margin-left:5px}
#main-content{background:#fff;}
#navigation-sub-content{background:#C7D3E0;margin-left:10px;font-size:9pt;line-height:1.5em}
#objectTypeHelp{font-size:10pt}
dl.edithelp {
    font-size:  9pt;
    margin:     .125em;
    max-width:  41em;
}
dl.edithelp dt {
    clear:       left;
    float:       left;
    padding-top: 3px;
    text-align:  right;
    color:       #ffe;
    white-space: nowrap;
}
dl.edithelp dd {
    padding-top: 3px;
    margin-left: 9.5em;
}
.hidden {
    visibility: hidden;
    display:    none;
}
.popup {
    position:         absolute;
    visibility:       hidden;
    top:              0px;
    left:             0px;
    color:            #dedede;
    background-color: #265990;
    border:           2px ridge #127;
    padding:          5px;
    font-size:        9pt;
}
.popup table {
    font-size:        9pt;
}
th{text-align:left}

EOF

$Radius::ServerHTTP::Connection::hardwired{'/js/utils.js'} = <<'EOF';
/**
 * A random assortment of javascript utility routines
 *
 * @url         $URL: http://cvs.mythtv.org/svn/branches/release-0-20-fixes/mythplugins/mythweb/js/utils.js $
 * @date        $Date: 2012/12/13 20:19:47 $
 * @version     $Revision: 1.38 $
 * @author      $Author: mikem $
 * @license     LGPL
 *
/**/

// Wrapper for various "get element id" functions
    function get_element(id) {
        if (typeof id != 'string') return id;
        if (document.getElementById)
            return document.getElementById(id);
        if (document.all)
            return document.all[id];
        return null;
    }

// For some reason, calling "value" from within onclick doesn't work
// Seems to be a name conflict somewhere, but I can't find it.
    function set_field(id, val) {
        value(id, val);
    }

// Pass in value to change, otherwise it returns the value of the "e" element
    function value(e, new_value) {
        if (typeof e == 'string')
            var e = get_element(e);
        if (!e) return '';
    // A <select>
        if (e.options) {
            if (new_value != null) {
            // This would scan the options and choose the one that matches
            // new_value.  Not used anywhere yet, so no need to hook it up.
            }
            return value(e.options[e.selectedIndex]);
        }
    // Just an html element?  (or in IE, an option element with no value="" specified)
        else if (e.value == null || e.tagName.toLowerCase() == 'option' && e.value == '') {
            if (new_value != null)
                e.innerHTML = new_value;
            return e.innerHTML;
        }
    // Form field
        if (new_value != null) {
            e.value = new_value;
        }
        return e.value;
    }

// Overwrite the href attribute of all <a> tags with a js_href attribute
    on_load.push(add_js_attributes);
    function add_js_attributes(w) {
        if (!w)
            w = window;
    // Get all links in this form
        var links = w.document.getElementsByTagName('a');
        for (var i=0; i<links.length; i++) {
        // js_href
            var js_href = links[i].getAttribute('js_href');
            if (js_href && js_href.length)
                links[i].href = js_href;
        // show the link title in the status bar
            if (!links[i].onmouseover && !links[i].onmouseout) {
                var title = links[i].getAttribute('title');
                if (title && title.length) {
                    links[i].onmouseover = function () {
                                               window.status = this.getAttribute('title');
                                               return true;
                                           }
                    links[i].onmouseout = function () {
                                              window.status = '';
                                              return true;
                                          }
                }
            }
        }
    // Process textareas, too
        var text = w.document.getElementsByTagName('textarea');
        for (var i=0; i<text.length; i++) {
            var auto = text[i].getAttribute('autorows');
            if (auto && auto.length) {
                if (parseInt(auto) < 1)
                    auto = null;
            // First, run textarea_autorows on the field as it stands now
                textarea_autorows(text[i], auto);
            // Then, populate the event code
                text[i].onkeyup = function () {
                                      textarea_autorows(this, this.getAttribute('autorows'));
                                  }
            }
        }
    // Handle any subframes
        if (w && w.frames) {
            for(var i=0; i<w.frames.length; i++){
                add_js_attributes(w.frames[i]);
            }
        }
    }

// Image Preloader
    var img_on  = new Array();
    var img_off = new Array();
    function preload_image(id, on, off) {
        img_on[id]      = new Image();
        img_on[id].src  = on;
        if (off) {
            img_off[id]     = new Image();
            img_off[id].src = off;
        }
    }

// Functions to swap on/off states of images
    function on(which) {
        var img = get_element(which);
        img.src=img_on[which].src;
    }
    function off(which) {
        var img = get_element(which);
        img.src=img_off[which].src;
    }

// Window status changer
    function wstatus(str) {
        window.status = str ? str : '';
        return true;
    }

// Submit a form
    function submit_form(newvar, val, form, confirm_str) {
    // Confirm?
        if (confirm_str && !confirm(confirm_str))
            return;
    // Find the form we want to submit
        form = get_element(form ? form : 'form');
        if (!form)
            form = document.form ? document.form : document.forms[0];
    // Create a new variable?
        if (newvar) {
            var hidden = document.createElement('input');
            hidden.type  = 'hidden';
            hidden.name  = newvar;
            hidden.value = val != null ? val : 1;
            form.appendChild(hidden);
        }
    // Submit
        form.submit();
    }

// Add a css class to a specified element
    function add_class(id, classname) {
        var field = get_element(id);
    // No field
        if (!field)
            return;
    // Field already has this class, don't bother to add it again
        if (field.className && (new RegExp('\\b'+classname+'\\b')).test(field.className))
            return;
    // Add the class
        if (field.className)
            field.className = field.className + ' ' + classname;
        else
            field.className = classname;
    }

// Remove a css class from a particular element
    function remove_class(id, classname) {
        var field = get_element(id);
        if (!field)
            return;
        field.className = field.className.replace(RegExp('\\b'+classname+'\\s*\\b|\\b\\s*'+classname+'\\b', 'g'), '') ;
    }

// Check/uncheck a checkbox
    function toggle_checkbox(id, check) {
        var e = get_element(id);
        if (check)
            e.checked = true;
        else if (check != null)
            e.checked = false;
        else
            e.checked = e.checked ? false : true;
    }

// Change the help text
    function help_text(text) {
    // Set the text
        get_element('help_text').innerHTML = text;
        wstatus(text);
    // Toggle the regions
        toggle_vis('help_text_default');
        toggle_vis('help_text');
    // Return true so wstatus works
        return true;
    }

// Resize a the specified <textarea>
    function resize_textarea(id, rows, cols) {
        var text = get_element(id);
        text.rows = rows != null ? rows : value(id + '_rows');
        text.cols = cols != null ? cols : value(id + '_cols');
    }

// Adjust the number of rows in textarea id to match the number of lines it has
    function textarea_autorows(element, max) {
        if (typeof element != 'object')
            element = get_element(element);
        var text = element.value;
    // First, scan for newlines
        var list = text.match(/\n/g);
        var rows = parseInt((list && list.length) ? list.length + 1 : 0);
    // Next, scan for extra-long lines that may have wrapped (not perfect, but close enough)
        var re = new RegExp('(\\S [^\n]{'+(parseInt(element.cols)-2)+',})(?!\n)', 'g');
        list   = text.match(re);
        if (list && list.length) {
            for (line in list) {
                rows += parseInt(list[line].length / element.cols) + 1;
            }
        }
    // Apply
        if (rows < 1)
            rows = 1;
        if (max != null && max < rows)
            rows = max;
        if (element.rows != rows)
            element.rows = rows;
    }

// Return a time in hours and minutes
    function nice_length(mylength, rx_hr, rx_hrs, rx_min, rx_mins) {
        var mins  = Math.round((mylength % 3600) / 60);
        var hours = Math.round(mylength / 3600);
        var ret;
        if (hours) {
            if (hours > 1)
                ret = rx_hrs.replace(/\$1/, hours);
            else
                ret = rx_hr.replace(/\$1/, hours);
        }
        else
            ret = '';
        if (mins > 0) {
            if (ret.length)
                ret = ret + ' ';
            if (mins > 1)
                ret = ret + rx_mins.replace(/\$1/, mins);
            else
                ret = ret + rx_min.replace(/\$1/, mins);
        }
        return ret;
    }

// Return a human-readable filesize
    function nice_filesize(size) {
        var kb = 1024;         // Kilobyte
        var mb = 1024 * kb;    // Megabyte
        var gb = 1024 * mb;    // Gigabyte
        var tb = 1024 * gb;    // Terabyte
    //  If it's less than a kb we just return the size
        if (size < kb)
            return size + ' B';
    // Otherwise we keep going until the size is in the appropriate measurement range.
        else if (size < mb)
            return Math.round(size/kb) + ' KB';
        else if (size < gb)
            return Math.round(size/mb) + ' MB';
        else if (size < tb)
            return Math.round(size/gb) + ' GB';
        else
            return Math.round(size/tb) + ' TB';
    }
// type chose in a object type choice menu
    function typeChosen(selectObj) {
	// get the index of the selected option 
	var idx = selectObj.selectedIndex; 
	// get the value of the selected option 
	var which = selectObj.options[idx].value; 
	var id = "helpitem_" + which;
	if (document.getElementById(id))
	{
	    document.getElementById("objectTypeHelp").innerHTML 
		= document.getElementById(id).innerHTML;
	}
	else
	{
	    document.getElementById("objectTypeHelp").innerHTML = " ";
	}
    }

EOF

$Radius::ServerHTTP::Connection::hardwired{'/js/init.js'} = <<'EOF';
/**
 * javascript initialization routine, and the content necessary to load the
 * other javascript files.
 *
 * @url         $URL: http://cvs.mythtv.org/svn/branches/release-0-20-fixes/mythplugins/mythweb/js/init.js $
 * @date        $Date: 2012/12/13 20:19:47 $
 * @version     $Revision: 1.38 $
 * @author      $Author: mikem $
 * @license     LGPL
 *
/**/

    window.onload = init;

// Define some global variables
    var isCSS, isW3C, isIE4, isNN4, isIE6, is_gecko, is_safari, is_khtml, is_opera;
    var on_load = new Array();                // An array of functions to be executed in init()

    function init() {
        var ua    = navigator.userAgent.toLowerCase();
        isCSS     = (document.body && document.body.style);
        isW3C     = (isCSS && document.getElementById);
        isIE4     = (isCSS && document.all);
        isNN4     = (document.layers) ? true : false;
        isIE6     = (document.compatMode && document.compatMode.indexOf("CSS1") >= 0);
        is_gecko  = ((ua.indexOf('gecko') != -1) && (ua.indexOf('spoofer') == -1) && (ua.indexOf('khtml') == -1) && (ua.indexOf('netscape/7.0') == -1));
        is_safari = ((ua.indexOf('AppleWebKit')!=-1) && (ua.indexOf('spoofer')==-1));
        is_khtml  = (navigator.vendor == 'KDE' || ( document.childNodes && !document.all && !navigator.taintEnabled ));
        is_opera  = (ua.indexOf('opera') != -1);

        for (var key in on_load) {
            on_load[key]();
        }
    }
EOF

$Radius::ServerHTTP::Connection::hardwired{'/js/browser.js'} = <<'EOF';
/**
 * Revised/updated javascript browser detection.
 *
 * Based loosely on the ideas found here:
 *
 *     http://webreference.com/tools/browser/javascript.html
 *     http://www.mozilla.org/docs/web-developer/sniffer/browser_type.html
 *
 * Rewritten from scratch to be LGPL and easier to maintain.  Also removed
 * support for some really old browsers that no one should be running anymore.
 *
 * I've left out detection of weird/nonstandard browsers and OS's because they
 * represent such a tiny portion of the market that I don't expect any of my
 * javascript code to work with them, anyway.  I've also decided to drop
 * support for anything earlier than version 4 browsers because of their lack
 * of the RegExp object.
 *
 * @url         $URL: http://cvs.mythtv.org/svn/branches/release-0-20-fixes/mythplugins/mythweb/js/browser.js $
 * @date        $Date: 2012/12/13 20:19:47 $
 * @version     $Revision: 1.38 $
 * @author      $Author: mikem $
 * @copyright   Silicon Mechanics
 * @license     LGPL
 *
 * @package     SiMech
 * @subpackage  Javascript
 *
/**/

// To avoid stepping on other variables, store everything in its own object
    var browser = new Object();

// Get lowercase versions of the browser agent and app version strings for
// easier testing.
    browser.ua    = navigator.userAgent.toLowerCase();
    browser.v_app = navigator.appVersion.toLowerCase();

// Default minor version (major is calculated below)
    browser.v_minor = parseFloat(browser.v_app);

/***************************** Operating Systems *****************************/

    browser.is_mac     = (browser.ua.indexOf('mac')     != -1);
    browser.is_bsd     = (browser.ua.indexOf('bsd')     != -1);
    browser.is_freebsd = (browser.ua.indexOf('freebsd') != -1);
    browser.is_linux   = (browser.ua.indexOf('linux')   != -1);
    browser.is_solaris = (browser.ua.indexOf('sunos')   != -1);
    browser.is_x11     = (browser.ua.indexOf('x11')     != -1);
    browser.is_win     = (!browser.is_mac      && !browser.is_bsd
                          && !browser.is_linux && !browser.is_solaris && !browser.is_x11
                          && (browser.ua.indexOf('windows')  != -1
                              || browser.ua.indexOf('16bit') != -1
                              || browser.ua.indexOf('32bit') != -1));

/***************************** User Environment *****************************/

// Screen dimensions
    browser.screen_w  = parseInt(screen.width);
    browser.screen_h  = parseInt(screen.height);

// Window dimensions
    if (document.documentElement && document.documentElement.clientWidth) {
        browser.window_w = parseInt(document.documentElement.clientWidth);
        browser.window_h = parseInt(document.documentElement.clientHeight);
    }
    else if (document.body && document.body.clientWidth) {
        browser.window_w = parseInt(document.body.clientWidth);
        browser.window_h = parseInt(document.body.clientHeight);
    }
    else {
        browser.window_w = parseInt(window.innerWidth);
        browser.window_h = parseInt(window.innerHeight);
    }

// Window position
    if (window.screenLeft || window.screenTop) {
        browser.window_l = parseInt(window.screenLeft);
        browser.window_t = parseInt(window.screenTop);
    } else {
        browser.window_l = parseInt(window.screenX);
        browser.window_t = parseInt(window.screenY);
    }

/********************************* Browsers *********************************/

// Spoofing browsers
    browser.is_spoofer    = (browser.ua.indexOf('spoofer')    != -1);
    browser.is_compatible = (browser.ua.indexOf('compatible') != -1);

// Opera
    browser.is_opera = (browser.ua.indexOf('opera') != -1);
    browser.v_opera = browser.is_opera
                        ? parseFloat(browser.ua.match(RegExp('opera[\\s/]+([0-9\.]+)'))[1])
                        : 0;
    if (browser.v_opera > 0)
        browser.v_minor = parseFloat(browser.v_opera);

// Apple's webkit is the whole package surrounding their version of KHTML.  If
// a browser uses the webkit, it should be considered identical to safari.
    browser.is_applewebkit = (!browser.is_opera && browser.is_mac && browser.ua.indexOf('applewebkit') != -1);
    browser.v_applewebkit  = browser.is_applewebkit
                               ? parseFloat(browser.ua.match(RegExp('applewebkit[\\s/]+([0-9\.]+)'))[1])
                               : 0;

// Safari
    browser.is_safari = (browser.is_mac && browser.ua.indexOf('safari') != -1);
    browser.v_safari  = browser.is_safari
                          ? parseFloat(browser.ua.match(RegExp('safari[\\s/]+([0-9\.]+)'))[1])
                          : 0;
    if (browser.v_safari > 0)
       browser.v_minor = parseFloat(browser.v_safari);

// Shiira, another mac browser (it will also show up as safari)
    browser.is_shiira = (browser.is_mac && browser.ua.indexOf('shiira') != -1);
    browser.v_shiira  = browser.is_shiira
                          ? parseFloat(browser.ua.match(RegExp('shiira[\\s/]+([0-9\.]+)'))[1])
                          : 0;
    if (browser.v_shiira > 0)
       browser.v_minor = parseFloat(browser.v_shiira);

// Konqueror
    browser.is_konq = (browser.ua.indexOf('konqueror') != -1);
    browser.v_konq  = browser.is_konq
                        ? parseFloat(browser.ua.match(RegExp('konqueror[\\s/]+([0-9\.]+)'))[1])
                        : 0;
    if (browser.v_konq > 0)
       browser.v_minor = parseFloat(browser.v_konq);

// KHTML
    browser.is_khtml = (browser.is_applewebkit || browser.ua.indexOf('khtml') != -1);

// Internet Explorer
    browser.is_ie = (!browser.is_opera && !browser.is_khtml && browser.ua.indexOf('msie') != -1);
    if (browser.is_ie && browser.ua.indexOf('msie 5.5') != -1)
        browser.v_ie = 5.5;
    else
        browser.v_ie  = browser.is_ie
                            ? parseFloat(browser.ua.match(RegExp('msie[\\s/]+([0-9\.]+)'))[1])
                            : 0;
    if (browser.v_ie > 0)
       browser.v_minor = parseFloat(browser.v_ie);

// Gecko browsers
    browser.is_gecko = (!browser.is_opera && !browser.is_khtml && !browser.is_ie
                        && browser.ua.indexOf('gecko') != -1);
    browser.v_gecko  = browser.is_gecko
                         ? navigator.productSub
                         : 0;

    browser.is_firefox = false;
    browser.is_camino  = false;
    browser.is_mozilla = false;
    if (browser.is_gecko         && !browser.is_spoofer && !browser.is_compatible
            && !browser.is_opera && !browser.is_webtv   && !browser.is_hotjava) {
    // Mozilla browsers
        if (browser.ua.indexOf('mozilla/5') != -1) {
        // Camino
            browser.is_camino = (navigator.vendor=='Camino' || browser.ua.indexOf('camino') != -1);
            browser.v_camino  = browser.is_camino
                                  ? parseFloat(browser.ua.match(RegExp('camino[\\s/]+([0-9\.]+)'))[1])
                                  : 0;
            if (browser.v_camino)
                browser.v_minor = browser.v_camino;
        // Firefox (or firebird)
            browser.is_firefox = (navigator.vendor == 'Firefox'     || browser.ua.indexOf('firefox')  != -1
                                  || navigator.vendor == 'Firebird' || browser.ua.indexOf('firebird') != -1);
            browser.v_firefox  = browser.is_firefox
                                   ? parseFloat(browser.ua.match(RegExp('firefox[\\s/]+([0-9\.]+)'))[1])
                                   : 0;
            if (browser.v_firefox)
                browser.v_minor = browser.v_firefox;
        // Vanilla Mozilla
            browser.is_mozilla = (!browser.is_firefox && !browser.is_camino
                                  && (navigator.vendor == '' || navigator.vendor == 'Mozilla' || navigator.vendor == 'Debian'));
            if (browser.is_mozilla) {
                browser.v_mozilla = (navigator.vendorSub) ? navigator.vendorSub : 0;
                if (!browser.v_mozilla)
                    browser.v_mozilla = parseFloat(browser.ua.match(RegExp(';\\s*rv\:\\s*(.+?)\\)'))[1]);
                browser.v_minor   = parseFloat(browser.v_mozilla);
            }
        }
    // Netscape Navigator
        if (!browser.is_gecko && !browser.is_camino && !browser.is_mozilla
                && browser.ua.indexOf('mozilla') != -1) {
            browser.is_navigator = true;
        // Netscape 6
            if (navigator.vendor && navigator.vendor.match(RegExp('^Netscape6?$'))) {
                browser.v_navigator = parseFloat(navigator.vendorSub);
                browser.v_minor     = browser.v_navigator;
            }
        // Navigator-only
            browser.is_navigator_only = (browser.ua.match(RegExp('; ?nav')));
        }
    }

// KNOWN BUG: AOL 4 returns false if IE 3 is the embedded browser or if it is
// the first browser window opened.  Thus is_aol isn't completely reliable, as
// it may show up as version 3 due to the IE version.
    browser.is_aol = (browser.ua.indexOf('aol') != -1);
    if (browser.is_aol && is_ie && browser.v_ie <= 4)
        browser.v_aol = browser.v_ie;
    else
        browser.v_aol = browser.is_aol
                            ? parseFloat(browser.ua.match(RegExp('aol[\\s/]*([0-9\.]+)'))[1])
                            : 0;
    if (browser.v_aol)
        browser.v_minor = browser.v_aol;

// Lastly, calculate the major version from the minor version
    browser.v_major = parseInt(browser.v_minor);

/***************************** Browser Features *****************************/

// Couple of useful checks
    browser.is_css = (document.body  && document.body.style)
    browser.is_w3c = (browser.is_css && browser.getElementById)

// Cookie support -- only create a cookie if there isn't one already.  It seems
// that doing this can override the exipiration info in existing cookies.
    browser.cookies = (document.cookie) ? true : false;
    if (!browser.cookies) {
        var tmp = document.cookie;
        document.cookie = 'cookie_test=true';
        browser.cookies = (document.cookie) ? true : false;
        document.cookie = tmp;
    }

// Java support
    browser.java = navigator.javaEnabled();

/****************************** Plugin Support ******************************/

// Various plugins
    browser_check_plugin('flash',     'application/x-shockwave-flash', 'ShockwaveFlash.ShockwaveFlash');
    browser_check_plugin('realaudio', 'audio/x-pn-realaudio-plugin',   'rmocx.RealPlayer G2 Control');
    browser_check_plugin('quicktime', 'video/quicktime',               'QuickTimeCheckObject.QuickTimeCheck');
    browser_check_plugin('wma',       'application/x-mplayer2',        'MediaPlayer.MediaPlayer');

// There are two different strings for acrobat detection in IE
    browser_check_plugin('pdf',       'application/pdf',               'AcroPDF.PDF');  // Acrobat 7
    if (!browser.pdf)
        browser_check_plugin('pdf',   'application/pdf',               'PDF.PdfCtrl');  // Acrobat <= 6
    if (browser.v_pdf == 1)
        browser.v_pdf = 4;

// Multiple checks for SVG support
    browser_check_plugin('svg',       'image/svg+xml',                 'Adobe.SVGCtl');
    if (!browser.svg)
        browser.svg = document.implementation.hasFeature('org.w3c.dom.svg', '');

// A function to simplify detecting plugins
    function browser_check_plugin(prop, mime_type, plugin_name) {
        browser[prop]        = false;
        browser['v_' + prop] = 0;
    // Smart browsers
        if (navigator.mimeTypes.length > 0) {
            var plugin = navigator.mimeTypes[mime_type]
                            ? navigator.mimeTypes[mime_type].enabledPlugin
                            : null;
            if (plugin && plugin.description) {
                browser[prop]        = true;
                browser['v_' + prop] = parseInt(plugin.description.substring(plugin.description.indexOf('.') - 1));
            }
        }
    // IE
        else if (browser.is_ie && !browser.is_mac) {
            document.write('<scr' + 'ipt language="VBScript">'          + '\n' +
                           'Dim has_plugin, plugin_version'             + '\n' +
                           'has_plugin     = false'                     + '\n' +
                           'plugin_version = 10'                        + '\n' +
                           'Do While plugin_version > 0'                + '\n' +
                           '   On Error Resume Next'                    + '\n' +
                           '   has_plugin = (IsObject(CreateObject("' + plugin_name + '." & plugin_version)))' + '\n' +
                           '   If has_plugin = true Then Exit Do'       + '\n' +
                           '   plugin_version = plugin_version - 1'     + '\n' +
                           'Loop'                                       + '\n' +
                           'browser.v_' + prop + ' = playerversion'     + '\n' +
                           'browser.'   + prop + ' = has_plugin'        + '\n' +
                           '<\/sc' + 'ript>'
                          );
        }
   }

EOF

$Radius::ServerHTTP::Connection::hardwired{'/js/mouseovers.js'} = <<'EOF';
/**
 * Functions to show/hide sections of the page (for mouseovers).
 * Primarily used for interactive menus
 *
 * @url         $URL: http://cvs.mythtv.org/svn/branches/release-0-20-fixes/mythplugins/mythweb/js/mouseovers.js $
 * @date        $Date: 2012/12/13 20:19:47 $
 * @version     $Revision: 1.38 $
 * @author      $Author: mikem $
 * @license     LGPL
 *
 * @package     MythWeb
 * @subpackage  Javascript
 *
/**/

// Make a reasonable attempt to determine the css position of a particular field.
    function get_css_position(field) {
        var e = get_element(field);
    // Display assigned directly to the element
        if (e.style.position)
            return e.style.position;
    // Unknown display type -- Make a reasonable effort to look it up in the stylesheet rules
        var classes = e.className.split(/\s+/);
        var found   = false;
        for (var i=0;i<document.styleSheets.length;i++) {
            var sheet = document.styleSheets[i];
            var rules = (typeof sheet.cssRules != 'undefined') ? sheet.cssRules
                            : ((typeof sheet.rules != 'undefined') ? sheet.rules : null);
            if (rules) {
                for (var j=0;j<rules.length;j++) {
                    var rule = rules[j];
                // No display rule given -- skip ahead early
                    if (!rule || !rule.style || !rule.style.position)
                        continue;
                // Grab the selectors and scan through them for id or rudimentary class name matches
                    var selectors = rule.selectorText.split(/\s*,\s*/);
                    for (var k=0;k<selectors.length;k++) {
                        var str = selectors[k];
                    // See if this is a matching id-based class
                        var match = new RegExp('^#'+field+'$');
                        if (str.match(match)) {
                            return e.style.position = rule.style.position;
                        }
                    // Nope -- scan through this field's classnames for a match
                        else {
                            for (var l=0;l<classes.length;l++) {
                                match = new RegExp('^\.'+classes[l]+'$');
                                if (str.match(match)) {
                                    return e.style.position = rule.style.position;
                                }
                            }
                        }
                    }
                }
            }
        }
    // Return the default
        return '';
    }

/**
 * find_position:
 *  returns the page position of any element on the screen
 *  thanks to webreference.com for info about tables, etc.
/**/
    function find_position(element, parse_absolute) {
    // Pull off the height/width early
        var w = element.offsetWidth  ? element.offsetWidth  : 0;
        var h = element.offsetHeight ? element.offsetHeight : 0;
    // No parent, just return the coordinates
        if (! element.offsetParent)
            return {x:element.x, y:element.y, w:w, h:h};
    // Scan backwards through the parents
        var x = 0, y = 0;
        do {
        // Ignore absolutely-positioned elements
            if (!parse_absolute && element.style && element.id && get_css_position(element.id) == 'absolute') {
                x -= parseInt(element.scrollLeft);
                y -= parseInt(element.scrollTop);
                continue;
            }
        /// I don't know why safari sets an offsetTop on the body element
            else if (element.tagName == 'BODY')
                continue;
        // If IE...
            if (browser.is_ie) {
                // If element is not a table or body tag, append the cell border info
                if (element.tagName != 'TABLE' && element.tagName != 'BODY') {
                    if (element.clientLeft)
                        x += parseInt(element.clientLeft);
                    if (element.clientTop)
                        y += parseInt(element.clientTop);
                }
            }
        // Gecko?
            else {
            // We need to take the table border into consideration
                if (element.tagName == 'TABLE') {
                    var border = parseInt(element.border);
                // No visible border, check for a frame attribute
                    if (isNaN(border)) {
                        var frame = element.getAttribute('frame');
                    // Found a frame attribute, but only add one pixel for it.
                        if (frame != null) {
                            x++;
                            y++;
                        }
                    }
                // Visible border, add it to the calculation, too
                    else if (border > 0) {
                        x += border;
                        y += border;
                    }
                }
            }
        // Don't forget the actual location of the element
            x += parseInt(element.offsetLeft) - parseInt(element.scrollLeft);
            y += parseInt(element.offsetTop)  - parseInt(element.scrollTop);
        } while (element = element.offsetParent);
        return {x:parseInt(x), y:parseInt(y), w:parseInt(w), h:parseInt(h)};
    }

// Keep track of things
    var popups        = new Array();
    var popup_timeout = null;

// Popup boxes that disappear when the mouse leaves the parent area
    function popup(id, popup_id, x, y, click, menu) {
    // Need a popup id?
        if (!popup_id || popup_id.length < 1)
            popup_id = id + '_popup';
    // Add the obligatory _popup suffix
        else if (!get_element(popup_id))
            popup_id += '_popup';
    // No popup id element defined; just return (page probably isn't done loading)
        if (!get_element(popup_id))
            return;
    // Popup already showing with this content
        if (popups.length && popups[0].id == id) {
            if (click) {
            // Already a clicked-type, just hide it
                if (popups[0].click) {
                    hide_popup();
                    return;
                }
            // Make the current instance of this ignore mouseout events
            // (it will get hidden shortly, to visibly notify the user of the
            // change, and this will keep the "click" version from hiding
            // itself unnecessarily)
                else {
                    get_element(popups[0].id).onmouseout       = null;
                    get_element(popups[0].popup_id).onmouseout = null;
                }
            }
            else if (popups[0].click) {
                return;
            }
        // This popup is already visible -- cancel any "hide" commands and return
            else {
                clear_popup_timeout();
                return;
            }
        }
    // Hide all other popups, in case one was stuck on
        hide_popup();
    // Create the object and add it to the list
        popups.unshift(new popup_obj(id, popup_id, x, y, click, menu));
    // delaying show_popup() seems to make it more accurate at positioning things
        setTimeout(show_popup, 50);
    }

// An object for all popup types
    function popup_obj(id, popup_id, x, y, click, menu) {
    // menu and click tend to conflict, so let menu override
        if (menu)
            this.menu = true;
        else {
            this.menu = false;
            this.click = click ? true : false;
        }
    // Make sure that x and y are numbers
        this.x = isNaN(x) ? 0 : x;
        this.y = isNaN(y) ? 5 : y;
    // Get the name and popup name
        this.id = id;
        if (popup_id && popup_id.length > 0)
            this.popup_id = popup_id;
        else
            this.popup_id = id;
    // Set the mouseout behavior
        var field = get_element(this.id)
        if (!click)
            field.onmouseout = timed_hide_popup;
    // Set the mouseover behavior for the child
        field = get_element(this.popup_id)
        if (menu)
            field.onmouseover = show_popup;
        if (!click)
            field.onmouseout  = timed_hide_popup;
    // Adjust the z-index of the popup so that it shows on top of the parent menu
        field.style.zIndex = 99 + popups.length + 10;
    }

    function show_popup() {
        if (popup_timeout) {
            clear_popup_timeout();
            return;
        }
    // No need to do this?
        if (!popups[0])
            return;
    // Grab the current element to be shown
        var popup = popups[0];
        var field = get_element(popup.popup_id);
        if (field.style)
            field = field.style;
    // Allow the browser to render the popup in context
        field.display = 'inline';
    // Get the location of the parent element
        var pos = find_position(get_element(popup.id), true);
    // Grab another copy, since "field" is most likely a "style" now
        var orig_field = get_element(popup.popup_id);
        var width      = parseInt(orig_field.offsetWidth);
        var height     = parseInt(orig_field.offsetHeight);
    // Set the initial position of the hidden element
        var x = pos.x;
        var y = pos.y + parseInt(get_element(popup.id).offsetHeight);
    // Get some window information so we can make sure the box doesn't extend off the edge of the screen
        var window_width = 0, window_height = 0, scroll_left = 0, scroll_top = 0;
        if (document.documentElement.clientWidth) {
            window_width  = document.documentElement.clientWidth;
            window_height = document.documentElement.clientHeight;
            scroll_left   = document.documentElement.scrollLeft;
            scroll_top    = document.documentElement.scrollTop;
        }
        else if (document.body.clientWidth || document.body.clientHeight) {
            window_width  = document.body.clientWidth;
            window_height = document.body.clientHeight;
            scroll_left   = document.body.scrollLeft;
            scroll_top    = document.body.scrollTop;
        }
        else {
            window_width  = window.innerWidth;
            window_height = window.innerHeight;
            scroll_left   = document.body.scrollLeft;
            scroll_top    = document.body.scrollTop;
        }
    // Do our best to try to keep the popup onscreen and away from the parent
    // element (plus a screen-edge padding of 3 pixels)
        if (window_width > 0 && window_height > 0) {
        // Adjust the element location?
            if (x > window_width + scroll_left - width - 6)
                x = window_width + scroll_left - width - 6;
            if (window_height > 200 && y > window_height + scroll_top - height - 6)
                y -= height + get_element(popup.id).offsetHeight + 6;
        }

    // Don't hide off the left side of the screen
        if (x < 0) x = 0;
        if (y < 0) y = 0;
    // Adjust the element
        field.left    = (x + 3) + 'px';
        field.top     = (y + 13) + 'px';
    // Finally, make it visible
        field.visibility = 'visible';
    }

// This sets up a timeout so the popup isn't hidden immediately
    function timed_hide_popup() {
        clear_popup_timeout();
    // Set the timeout
    	if (popups.length > 0)
            popup_timeout = setTimeout('hide_popup()', popups[0].menu ? 500 : 5);
    // Let events bubble down
        no_bodyclick = false;
    }
// Hides all popups (so only one can be visible at any given time)
    function hide_popup() {
    // Clear the timeout, and hide any visible popups
        clear_popup_timeout();
        while (popups.length > 0) {
            var popup = popups.shift();
            var field = get_element(popup.popup_id);
            if (field != null) {
                if (field.style)
                    field = field.style;
                field.visibility = 'hidden';
                field.display    = 'none';
            }
        }
    }
// Clear any popup-related timeouts
    function clear_popup_timeout() {
        if (!popup_timeout)
            return
        clearTimeout(popup_timeout);
        popup_timeout = null;
    }

/*
    Thanks to Phrogz for setting me straight about menus.
    http://phrogz.net/JS/ul2menu/index.html
*/

// Register a popup menu, to be processed upon window load
    var menus = new Array();
    function register_menu(id) {
        menus.push(id);
    }

    on_load.push(init_menus);
    function init_menus() {
        if(!menus.length)
            return 0;
        for (var i=0;i<menus.length;i++) {
            var menu = get_element(menus[i]);
            if (!menu)
                continue;
            var items = menu.getElementsByTagName('li');
            var l = items.length;
            for (var j=0; j<l; j++) {
                var li = items[j];
            // Needs an id?  Make a semi-random one
                if (!li.id)
                    li.id = menu.id + '.' + (j + Math.random());
            // Find the immediate parent menu item, if there is one
                li.parent = li;
                while (li.parent) {
                    li.parent = li.parent.parentNode;
                    if (li.parent && li.parent.tagName == 'LI')
                        break;
                }
                if (!li.parent || li.parent && li.parent.tagName != 'LI')
                    li.parent = null;
            // We should probably only interact with the first <ul> we find -- treat it as a submenu
                var children = li.getElementsByTagName('ul');
                if (!children || children.length == 0)
                    continue;
                li.child = children[0];
            // Child needs an id, too?
                if (!li.child.id)
                    li.child.id = li.id + '.' + (10 * Math.random());
            // Set the mouseover/mouseout events
                li.onmouseover = show_menu_delayed;
                li.onmouseout  = hide_menu_delayed;
            // Gather some other info about this menu
                li.top_menu = (li.parentNode == menu);
                if (menu.className)
                    li.vertical = (li.top_menu && menu.className && (new RegExp('\\bvertical\\b')).test(menu.className));
                else
                    menu.className = 'horizontal';
            // Nothing left to test?
                if (li.top_menu || li.has_arrow)
                    continue;
            // Do we need to add anything to indicate this as a submenu?
                var a = li.getElementsByTagName('a');
                if (a && a.length > 0 && a[0].parentNode == li)
                    a[0].innerHTML = '<span style="float: right">&nbsp;&rArr;</span>' + a[0].innerHTML;
                else {
                    var arrow = document.createElement('span');
                    arrow.innerHTML='&nbsp;&rArr;';
                    arrow.style.cssFloat = arrow.style.styleFloat = 'right';
                    li.insertBefore(arrow,li.childNodes[0]);
                }
                li.has_arrow=true;
            }
        }
    }

    var menu_to_show;
    var menu_to_hide;
    var menu_show_timeout;
    var menu_hide_timeout;
    function show_menu_delayed(e) {
    // Make sure only ONE event fires
        if (!e) var e = window.event;
        e.cancelBubble = true;
        if (e.stopPropagation)
            e.stopPropagation();
    // Show this menu
        menu_to_show = this;
    // A menu is set to hide?
        if (menu_to_hide) {
        // Hiding this menu?  Cancel the request.
            if (menu_to_hide == this || menu_to_hide == this.parent)
                menu_to_hide = null;
        // Hiding another menu, just do it now
            else {
                hide_menu();
            }
        }
    // Show the new menu
        menu_show_timeout = setTimeout(show_menu, this.top_menu ? 250 : 50);
    }

    function show_menu() {
    // Loop to make sure we also show any parent menus that got hidden
        var this_menu = menu_to_show;
        while (this_menu) {
        // Make the menu active
            add_class(this_menu, 'active');
            var pos = find_position(this_menu);
            if (this_menu.top_menu) {
                pos.x += (this_menu.vertical ? pos.w : -1);
                pos.y += (this_menu.vertical ? 2     : pos.h - 2);
            }
            else {
                pos.x = this_menu.offsetWidth;
                pos.y = this_menu.offsetTop + 2;
            }
        // Make some corrections
            if (isNaN(pos.x) || pos.x < 0) pos.x = 0;
            if (isNaN(pos.y) || pos.y < 0) pos.y = 0;
        // Get some window information so we can make sure the menu doesn't extend off the edge of the screen
            var window_width = 0, scroll_left = 0;
            if (document.documentElement.clientWidth) {
                window_width  = document.documentElement.clientWidth;
                scroll_left   = document.documentElement.scrollLeft;
            }
            else if (document.body.clientWidth || document.body.clientHeight) {
                window_width  = document.body.clientWidth;
                scroll_left   = document.body.scrollLeft;
            }
            else {
                window_width  = window.innerWidth;
                scroll_left   = document.body.scrollLeft;
            }
        // Get the child field
            var child = this_menu.child;
            if (child.style)
                child = child.style;
        // Allow the browser to render the menu in context
            child.display = 'inline';
        // Make sure it doesn't hide beneath other objects
            child.zIndex  = 99;
        // Do our best to try to keep the menu onscreen
            if (window_width > 0) {
                var width = parseInt(this_menu.child.offsetWidth);
            // Adjust the element location?  Since it's nested position:absolute,
            // we need to gets its true location.
                if (find_position(this_menu).x > window_width + scroll_left - this_menu.offsetWidth - width) {
                // First level of menus should align with the right edge of the parent object
                    if (!this_menu.parent)
                        pos.x -= width - this_menu.offsetWidth;
                // Because it's nested position:absolute, submenus should subtract
                // width from zero (plus a few extra pixels to make it look nice)
                    else
                        pos.x = 5 - this_menu.offsetWidth;
                }
            }
        // Move the menu into its new location
            child.left = pos.x + 'px';
            child.top  = pos.y + 'px';
        // Show the menu
            child.visibility = 'visible';
        // Up to the next layer
            this_menu = this_menu.parent;
        }
    }

    function hide_menu_delayed(e) {
    // Make sure only ONE event fires
        if (!e) var e = window.event;
        e.cancelBubble = true;
        if (e.stopPropagation)
            e.stopPropagation();
    // Did we just show this menu?  Don't avoid closing it.
        if (menu_to_show == this) {
            menu_to_show = null;
        }
    // If the user was moving the mouse quickly, reset the counter so the delay is accurate
        clearTimeout(menu_hide_timeout);
    // Hide this menu
        menu_to_hide = this;
        menu_hide_timeout = setTimeout(hide_menu, 350);
    }

    function hide_menu() {
    // Process each menu we have to hide
        var this_menu = menu_to_hide;
        while (this_menu) {
        // Look for a common parent, so we only hide as many submenus as needed
            var found   = false;
            var submenu = menu_to_show;
            while (submenu) {
                if (submenu == this_menu) {
                    found = true;
                    break;
                }
                submenu = submenu.parent;
            }
            if (found)
                break;
        // Hide the menu
            var child = this_menu.child;
            if (child.style)
                child = child.style
            child.display    = 'none';
            child.visibility = 'hidden';
            remove_class(this_menu, 'active');
        // On to the parent menu
            this_menu = this_menu.parent;
        }
    // Don't need to hide this anymore
        menu_to_hide = null;
    }


EOF

1;
