# Monitor.pm
#
# Object for TCP connections and debugging/monitoring
# of Radiator internals.
# IT is designed principally to support a remote client program
# for probing internals and getting statistics, 
# but it can be used with telnet(1)
#
# Author: Mike McCauley (mikem@open.com.au)
# Copyright (C) 2001 Open System Consultants
# $Id: Monitor.pm,v 1.32 2012/06/27 23:27:18 mikem Exp $
package Radius::Monitor;
@ISA = qw(Radius::Configurable Radius::StreamServer);
use Radius::Configurable;
use Radius::StreamServer;
use Radius::Radius;
use Radius::Predicate;
use strict;

%Radius::Monitor::ConfigKeywords = 
('Username'                    => 
 ['string', 'This optional parameter specifies the username that must authenticate any connection through this Monitor clause. Username and Password will be checked if there are no AuthBy clauses, or if they all IGNORE the authentication.', 0],

 'Password'                    => 
 ['string', 'This optional parameter specifies the password that must authenticate any connection through this Monitor clause. Username and Password will be checked if there are no AuthBy clauses, or if they all IGNORE the authentication.', 0],

 'AuthByPolicy'                => 
 ['string', 
  'Specifies whether and how to continue authenticating after each AuthBy', 
  0],

 'TraceOnly'                   => 
 ['flag', 
  'Only provide Tracing services', 
  2],

 'StatisticsOnly'              => 
 ['flag', 
  'Only provide Statistics', 
  2],

 'AuthBy'                      => 
 ['objectlist', 
  'List of AuthBy clauses to use to handle authentication for new web connections. Requests are processed by each AuthBy in order until AuthByPolicy is satisifed. If there are no AuthBy clauses, the fallback Username and Password will be used', 
  0],

 'LogMicroseconds'             => 
 ['flag', 
  'When logging, include microseconds in the time (requires Time::HiRes)', 
  1],

 'AddToRequest'         => 
 ['string', 'This optional parameter adds any number of RADIUS attributes to the RADIUS requests generated by ServerHTTP. It can be used to tag authentication request requests for logging in users.', 1],
 );

# RCS version number of this module
$Radius::Monitor::VERSION = '$Revision: 1.32 $';

#####################################################################
sub activate
{
    my ($self) = @_;

    $self->Radius::Configurable::activate();
    $self->Radius::StreamServer::activate();
}

#####################################################################
# Do per-instance default initialization
# This is called by Configurable during Configurable::new before
# the config file is parsed. Its a good place initialize instance 
# variables
# that might get overridden when the config file is parsed.
# Do per-instance default initialization. This is called after
# construction is complete
sub initialize
{
    my ($self) = @_;

    $self->Radius::Configurable::initialize();
    $self->Radius::StreamServer::initialize();
    $self->{Port} = 9048;
    $self->{ObjType} = 'Monitor'; # Auto register with Configurable
}

#####################################################################
# This is called by StreamServer when a new connetion has been made
sub handle_new_connection
{
    my ($self, $newsocket) = @_;

    Radius::MonitorConnection->new
	($self, $newsocket,
	 MaxBufferSize             => $self->{MaxBufferSize},
	 UseSSL                    => $self->{UseSSL},
	 AddToRequest              => $self->{AddToRequest},
	 TLS_ExpectedPeerName      => $self->{TLS_ExpectedPeerName},
	 TLS_SubjectAltNameURI     => $self->{TLS_SubjectAltNameURI},
	 TLS_CertificateFingerprint=> $self->{TLS_CertificateFingerprint},
	 TLS_PrivateKeyPassword    => $self->{TLS_PrivateKeyPassword},
	 TLS_CertificateType       => $self->{TLS_CertificateType},
	 TLS_CertificateFile       => $self->{TLS_CertificateFile},
	 TLS_CertificateChainFile  => $self->{TLS_CertificateChainFile},
	 TLS_PrivateKeyFile        => $self->{TLS_PrivateKeyFile},
	 DisconnectErrorLevel      => $main::LOG_DEBUG,
	 );
}

#####################################################################
sub destroy
{
    my ($self) = @_;

    $self->Radius::StreamServer::destroy();
}

#####################################################################
#####################################################################
#####################################################################
package Radius::MonitorConnection;
use vars qw(@ISA);
@ISA = qw(Radius::StreamServer::Connection);

#####################################################################
sub new
{
    my ($class, $parent, $socket, %args) = @_;

    my $self = $class->SUPER::new($parent, $socket, %args);
    # the constructor can fail 
    if ($self)
    {
	$self->{recsep} = "\n";
	$self->{Trace} = 0; # Default trace level
	$self->{trace_nopacket} = 1;
	$parent->log($main::LOG_DEBUG,  "New MonitorConnection created for $self->{Host}:$self->{Port}");
	
	# We act like a global logger too
	&Radius::LogGeneric::add_logger($self);
    }
    return $self;
}

#####################################################################
# Called by Stream when more data has been read from the socket
sub read_data
{
    my ($self) = @_;

    while ($self->{inbuffer} ne '')
    {
	# Look for EOL. If found, its the end of the command
	my $index = index($self->{inbuffer}, $self->{recsep});
	if ($index >= 0)
	{
	    my $buffer = substr($self->{inbuffer}, 0, $index);
	    # Remove the record and the record sep
	    substr($self->{inbuffer}, 0, $index + length $self->{recsep}) = '';
	    $buffer =~ s/[\012\015]//g if $self->{recsep} eq "\n";
	    $self->command($buffer);
	}
	else
	{
	    return; # No complete statement in buffer
	}
    }
    $self->{inbuffer} = undef; # Prevent inbuffer growing inf long
}

#####################################################################
# Called when a complete command has been received
# Parse and process it
sub command
{
    my ($self, $cmd) = @_;

    $self->{parent}->log($main::LOG_DEBUG,  "Monitor received command: $cmd");

    # Simple replay of commands
    $cmd = $self->{lastcommand} if ($cmd eq '');

    $self->{lastcommand} = $cmd;

    if ($cmd =~ /^ID/i)
    {
	return $self->writesep('NOTLOGGEDIN') unless $self->{loggedin};
	# Server ident message
	my $time = time;
	$self->writesep("ID $time $main::ident");
    }
    elsif ($cmd =~ /^TRACE\s+(\d+)/i)
    {
	return $self->writesep('NOTLOGGEDIN') unless $self->{loggedin};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{StatisticsOnly};
	# Set the current trace level for this client
	$self->{Trace} = $1;
	$self->writesep('TRACE');
    }
    elsif ($cmd =~ /^TRACE_USERNAME\s*(\S*)/i)
    {
	return $self->writesep('NOTLOGGEDIN') unless $self->{loggedin};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{StatisticsOnly};
	# Set the current trace username for this client
	$self->{trace_username} = $1;
	$self->writesep('TRACE_USERNAME');
    }
    elsif ($cmd =~ /^TRACE_NOPACKET\s*(\d+)/i)
    {
	return $self->writesep('NOTLOGGEDIN') unless $self->{loggedin};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{StatisticsOnly};
	# Set the current trace username for this client
	$self->{trace_nopacket} = $1;
	$self->writesep('TRACE_NOPACKET');
    }
    elsif ($cmd =~ /^TRACE_PREDICATE\s*(.*)/i)
    {
	return $self->writesep('NOTLOGGEDIN') unless $self->{loggedin};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{StatisticsOnly};
	# Set the current trace predicate for this client
	$self->{trace_predicate} = Radius::Predicate->new();
	$self->{trace_predicate}->parse($1);
	$self->writesep('TRACE_PREDICATE');
    }
    elsif ($cmd =~ /^STATS\s+(\S*)/i)
    {
	return $self->writesep('NOTLOGGEDIN') unless $self->{loggedin};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{TraceOnly};
	
	# Get the the statistics for the named object
	my $path = $1 || '.';
	my $o = findObject($path);
	if ($o && ref($o) =~ /^Radius::/)
	{
	    $self->writesep("STATS $path\n" . join("\001", map "$Radius::ServerConfig::statistic_names{$_}:$o->{Statistics}{$_}", (sort keys %Radius::ServerConfig::statistic_names)));
	}
	else
	{
	    $self->writesep('NOSUCHOBJECT');
	}
    }
    elsif ($cmd =~ /^DESCRIBE\s+(\S*)/i)
    {
	return $self->writesep('NOTLOGGEDIN') unless $self->{loggedin};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{TraceOnly};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{StatisticsOnly};
	# Describe the named object by returning a list of attribtues
	# and their types
	my $path = $1 || '.';
	my $o = findObject($path);
	if ($o && ref($o) =~ /^Radius::/)
	{
	    my %keywords = $o->configKeywords();

	    # Convert new config arrays to old config keyword type strings
	    map {$keywords{$_} = $keywords{$_}->[0] if ref($keywords{$_}) eq 'ARRAY'} (sort keys %keywords);

	    $self->writesep("DESCRIBE $path\n" . join("\001", "Type:objecttype:" . ref($o), map "$_:$keywords{$_}:" . $o->{$_}, (sort keys %keywords)));
	}
	else
	{
	    $self->writesep('NOSUCHOBJECT');
	}
    }
    elsif ($cmd =~ /^SET\s+(\S+)\s+(\S+)\s+(.*)/i)
    {
	return $self->writesep('NOTLOGGEDIN') unless $self->{loggedin};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{TraceOnly};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{StatisticsOnly};
	# Set the value of a variable
	my $path = $1 || '.';
	my $attribute = $2;
	my $value = $3;
	my $o = findObject($path);
	if ($o && ref($o) =~ /^Radius::/)
	{
	    $o->set($attribute, $value);
	    $self->writesep("SET $path $attribute $value\n");
	}
	else
	{
	    $self->writesep('NOSUCHOBJECT');
	}
    }
    elsif ($cmd =~ /^LIST\s+(\S+)/i)
    {
	return $self->writesep('NOTLOGGEDIN') unless $self->{loggedin};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{TraceOnly};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{StatisticsOnly};
	# List the index and Name of each object in an objectlist
	my $path = $1;
	my $o = findObject($path);
	if ($o && ref($o) eq 'ARRAY')
	{
	    $self->writesep("LIST $path\n" . join("\001", map {ref($$o[$_]) =~ /^Radius::/ ? "$_:object:$$o[$_]->{Name}" : "$_:uneditablestring:$$o[$_]"} (0 .. $#$o)));

	}
    }
    elsif ($cmd =~ /^LOGIN\s+(\S*)\s+(\S*)/i)
    {
	# The username to be logged in as
	$self->{username} = $1;
	$self->{password} = $2;
	$self->writesep($self->authenticate() ? 'LOGGEDIN' : 'BADLOGIN');
    }
    elsif ($cmd =~ /^CHALLENGE/i)
    {
	# Generate a challenge to use for logging in later
	$self->{lastchallenge} = Radius::Util::random_string(16);
	$self->writesep('CHALLENGE ' . unpack('H*', $self->{lastchallenge}));
    }
    elsif ($cmd =~ /^BINARY/i)
    {
	$self->{recsep} = "\000";
    }
    elsif ($cmd =~ /^RESTART/i)
    {
	return $self->writesep('NOTLOGGEDIN') unless $self->{loggedin};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{TraceOnly};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{StatisticsOnly};
	&main::request_reset();
    }
    elsif ($cmd =~ /^SAVE/i)
    {
	return $self->writesep('NOTLOGGEDIN') unless $self->{loggedin};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{TraceOnly};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{StatisticsOnly};
	my $error = $self->save_config();
	if ($error)
	{
	    $self->writesep("ERROR\n$error");
	}
	else
	{
	    $self->writesep("SAVED");
	}
    }
    elsif ($cmd =~ /^HELP/i)
    {
	# Help message
	$self->writesep("HELP
LOGIN name password
TRACE n
TRACE_PREDICATE attr == \"val\", attr < val, ...
STATS objname
DESCRIBE objname
SET objname paramname value
LIST objname
CHALLENGE
BINARY
RESTART
QUIT");
    }
    elsif ($cmd =~ /^GET\s+(\S+)/i)
    {
	return $self->writesep('NOTLOGGEDIN') unless $self->{loggedin};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{TraceOnly};
	return $self->writesep('NOPERMISSION') if $self->{parent}->{StatisticsOnly};
	# Get the value of a variable
    }
    elsif ($cmd =~ /^QUIT/i)
    {
	# Quit
	$self->stream_disconnected();
    }
    else
    {
	# Huh?
	$self->writesep('SYNTAXERROR');
    }
}

#####################################################################
# Called when a message is to be logged
# See if our trace level is high enough and send the message
# to the client
# $s is the message string
# $p is the current packet if any
sub log
{    
    my ($self, $priority, $s, $p) = @_;

    if ($self->willLog($priority, $p))
    {	    
	my $ctime = $self->{parent}->format_ctime();
	$self->writesep("LOG $ctime: $Radius::Log::priorityToString[$priority]: $s");
    }
}

#####################################################################
sub configKeywords
{
    return;
}

#####################################################################
# Return true if a message should be logged by this logger
# at the given log level (and matching an optional tracing username or predicate)
# If trace_predicate is not set, then trace_username (obsolete) will be used
sub willLog
{
    my ($self, $priority, $p) = @_;

    return (   $priority <= $self->{Trace} 
	    && (   (!$p && $self->{trace_nopacket})
	        || ($p && ($self->{trace_predicate} ? $self->{trace_predicate}->test($p) 
			       : (   ($self->{trace_username} eq '')
			          || ($p->getUserName() eq $self->{trace_username}))))));
}

#####################################################################
# Dummy function to intercept attempts to change the trace level
# due to SUGUSR1 etc.
# Does nothing
sub adjustTrace
{
}

#####################################################################
# Check the username and password are correct, if so
# permit further actions
sub authenticate
{
    my ($self) = @_;

    $self->{loggedin} = undef;

    # Force disconnection if it looks like password attack
    if ($self->{badauths}++ > 5)
    {
	$self->{parent}->log($main::LOG_WARNING,  "Too many bad authentications in MonitorConnection $self->{Host}:$self->{Port}");
	$self->stream_disconnected();
	return;
    }
    
    # First check the authenticators in the AuthBy list
    # Try all the authenticators in sequence until the AuthByPolicy
    # is satisfied
    # CAUTION: The handler might fork
    my ($handler, $reason, $p, $handled);
    foreach $handler (@{$self->{parent}{AuthBy}})
    {
	if (!$p)
	{
	    # Fake up a radius packet we can pass to the AuthBys
	    $p =  new Radius::Radius $main::dictionary;
	    $p->{rp} = new Radius::Radius $main::dictionary;
	    $p->addAttrByNum($Radius::Radius::USER_NAME, $self->{username});
	    $p->addAttrByNum($Radius::Radius::USER_PASSWORD, '**obscured**');
	    $p->set_code('Access-Request');
	    if ($self->{password} =~ /^{chap}(.*)/i)
	    {
		return unless $self->{lastchallenge};
		$p->addAttrByNum($Radius::Radius::CHAP_PASSWORD, 
				 pack('H*', $1));
		$p->addAttrByNum($Radius::Radius::CHAP_CHALLENGE, 
				 $self->{lastchallenge});
	    }
	    else
	    {
		# Plaintext password, fake the decoded password
		$p->{DecodedPassword} = $self->{password};
	    }
	    # Add arbitrary data to every request
	    $p->parse(&Radius::Util::format_special($self->{AddToRequest}))
		if (defined $self->{AddToRequest});

	    # Dump the fake radius request
	    &main::log($main::LOG_DEBUG, "Monitor Radius request packet dump:\n" . $p->dump)
		if (&main::willLog($main::LOG_DEBUG, $self));

	}

	# Make sure the authby is updated with stats
	push(@{$p->{StatsTrail}}, \%{$handler->{Statistics}});

	($handled, $reason) = $handler->handle_request($p);

	# Evaluate the AuthByPolicy
	last unless $self->{parent}->evaluatePolicy($self->{parent}{AuthByPolicy}, $handled);
    }
    if (defined $handled)
    {
	$self->{loggedin}++ if $handled == $main::ACCEPT;
	return $self->{loggedin} if $handled != $main::IGNORE;
    }

    # Did not pass any of the AuthBy, try the hardwired Username
    # as a last resort
    return unless $self->{parent}{Username} ne '' 
	&& $self->{username} eq $self->{parent}{Username};

    if ($self->{password} =~ /^{chap}(.*)/i)
    {
	return unless $self->{lastchallenge};
	# Chap password. First octet of the response is the CHAP identifier.
	# Rest of response is MD5(chap id + password + challenge)
	# However, must have issued a challenge already
	my $response = pack('H*', $1);
	$self->{loggedin}++
	    if $self->{lastchallenge} ne '' &&
	      Digest::MD5::md5(substr($response, 0, 1) . $self->{parent}{Password} . $self->{lastchallenge})
		eq substr($response, 1);
    }
    else
    {
	# Plaintext password
	$self->{loggedin}++
	    if $self->{password} eq $self->{parent}{Password};
    }
    return $self->{loggedin};
}


#####################################################################
# Override Stream::stream_disconnected and make sure we alsways
# get destroyed when the connection closes
sub stream_disconnected
{
    my ($self) = @_;

    # Deleting any references to this MonitorConnection will
    # cause it to be destroyed    
    &Radius::LogGeneric::remove_logger($self);
    $self->SUPER::stream_disconnected();
    $self->{parent}->log($main::LOG_DEBUG,  "MonitorConnection disconnected from $self->{Host}:$self->{Port}");
}

#####################################################################
# Find and return a Radiator internal object, given its name
# Names start with . which means the root object of the
# Radiator object tree (ie The ServerConfig at $main::config)
# Path elements are . separated. Each path element is either the
# name of an attribtue, or an integer index into an object array
# eg .Client.0.AuthBy.2
# is the third AuthBy object in the first Client in ServerConfig
sub  findObject
{
    my ($path) = @_;

    my @path = split(/\./, $path);
    my $o = $main::config; # base of the search

    foreach (@path)
    {
	my $pathel = $_;
	next if $pathel eq '';
	my $type = ref($o);
	if ($type =~ /^Radius::/)
	{
	    # Its a Radiator object
	    # Next element of the path should be the name of an attribute
	    $o = $o->{$pathel};
	}
	elsif ($type eq 'ARRAY')
	{
	    # Its an array ref, presumably of object addresses
	    $o = $$o[$pathel];
	}
	else 
	{
	    # huh?
	    return ;
	}
    }
    return $o;
}

#####################################################################
sub writesep
{
    my ($self, $s) = @_;

    $self->write($s . $self->{recsep});
}

#####################################################################
sub save_config
{
    my ($self) = @_;

    my $filename = $main::config->{configFilename};
    return "Could not make backup of configuration file $filename: $!"
	unless Radius::Util::save_backup($filename);

    return "Could not open file $filename for writing: $!"
	unless open(SAVEFILE, '>', $filename);

    my $date = localtime(time);

    print SAVEFILE <<"EOF";
# $filename
#
# Radiator configuration file
# Automatically generated by Monitor
# logged in as $self->{username}
# from client $self->{Host}:$self->{Port}
# on $date
#
EOF

    # Recursively descend through the config, 
    # saving each object to a file as we go
    $main::config->save_config(*SAVEFILE);
    close(SAVEFILE);
    return;
}

#####################################################################
# We can end up here when ServerConfig saves its Log list
# Do nothing
sub save_object
{
}

1;
