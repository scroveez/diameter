# Configurable.pm
#
# Object for handling configurable items
# This can be used as a general subclass for object that are configured
# from the configuration file.
#
# Optionally provides an object directory based on object type
# and Identifier. Default Identifiers are provided. Also provides
# generic object loading services.
#
# Author: Mike McCauley (mikem@open.com.au)
# Copyright (C) 1997-2001 Open System Consultants
# $Id: Configurable.pm,v 1.73 2014/02/06 21:36:44 hvn Exp $

package Radius::Configurable;
use Radius::Util;
use Time::Local;
use strict;

# This is a hash of standard configuration keywords understood by the class
# if a config keyword is not recognised in this hash, then the 'sub keyword'
# virtual function will be called. Therefore you should provide
# a class::ConfigKeywords hash for each class, and a sub keywords
# function to handle any unusual types of keywords. In this hash,
# the key is the parameter name (ie the keyword), and the value is an array of 
#  [keyword type, documentation, doc detail level]
%Radius::Configurable::ConfigKeywords = 
(
 'Identifier' => 
 ['string',
  'Short name which can identify this object in other objects',
  1],

 'Description' => 
 ['string',
  'Long text description of the purpose of this object. It is used for informational and documentation purposes only.',
  1],

 'Log' => 
 ['objectlist',
  'Loggers that log messages generated by this object',
  1],
 );

# RCS version number of this module
$Radius::Configurable::VERSION = '$Revision: 1.73 $';

# List of registered objects by object type and Identifier
%Radius::Configurable::byId = ();

# Make sure we get reinitialized on sighup
push(@main::reinitFns, \&reinitialize);

#####################################################################
# Table of functions for handling different types of keywords
# and setting the appropriate object data in the right way
# In each function, $_[0] is $self, $_[1] is the keyword and $_[2] is the value
# Each keyword type interprets the value in a differetn way
my %keywordDataTypes =
(
 'string' => sub {$_[0]->{$_[1]} = $_[2]},
 'integer' => sub {$_[0]->{$_[1]} = int $_[2]},
 # 0, NO, no, false, FALSE are 0, everything else (including empty string) is 1
 'flag' => sub {$_[0]->{$_[1]} = &Radius::Util::format_special($_[2]) =~ /0|no|false/i ? 0 : 1},
 'stringarray' => sub {push(@{$_[0]->{$_[1]}}, $_[2])},
 'splitstringarray' => sub {push(@{$_[0]->{$_[1]}}, split(/[\s,]+/, $_[2]))},
 # Stringhash is key, value
 # value is hashed by key
 'stringhash' => sub {my ($k,$v) = split(/,\s*/, $_[2], 2); $_[0]->{$_[1]}->{$k} = $v;},
 'splitstringhash' => sub {my ($k,$v) = split(/,\s*/, $_[2], 2); push(@{$_[0]->{$_[1]}->{$k}}, split(/[\s,]+/,$v))},
 # Perl code
 'hook' => sub {#print "hook $_[1] is $_[2]\n";
		$_[0]->{$_[1]} = $_[2];
		$_[0]->{"$_[1].compiled"} = eval($_[2]);
		$_[0]->log($main::LOG_ERR, 
			   "Compilation error in $_[1]: $@") if $@},
 # The identifier of an object. Special formatting characters are permitted for formatobjectlist.
 'objectlist' => sub {$_[0]->findAndUse($_[1], $_[2]);},
 'formatobjectlist' => sub {$_[0]->findAndUse($_[1], Radius::Util::format_special($_[2]));},
 # comma or space sep word list, keep count of each word in a hash
 'counthash' => sub {foreach (split(/[\s,]+/, $_[2])) {$_[0]->{$_[1]}{$_}++}},
 );

#####################################################################
# construct a new object and parse its configuration
# $file is the filehandle we are currently parsing
# $name is an optional unique name
# %args can be used to override the default initialization, before the
# config file is read
# CAUTION: it is required to call ->activate() after new and after changing 
# any instance configuration paramaters
sub new
{
    my ($class, $file, $name, %args) = @_;

    my $self = {};
    bless $self, $class;

    $self->{Name} = $name;

    # Call class specific object initialization
    $self->initialize();

    # Override the default initialization with any 
    # args from the caller:
    map {$self->{$_} = $args{$_}} (keys %args);

    # Or from the config file:
    $self->parse($file) if defined $file;

    return $self;
}

#####################################################################
# Do per-instance state creation or recreation. This must be called
# for all subclasses of Configurable in order to activate 
# any changes in configuration.
# Override in subclasses
sub activate
{
#    my ($self) = @_;

}

#####################################################################
# Do per-instance default initialization
# Override in subclasses
sub initialize
{
#    my ($self) = @_;

}

#####################################################################
# Do per-instance configuration check
# Override in subclasses
sub check_config
{
#    my ($self) = @_;

}

#####################################################################
# Parse out each line in the config file until we see something like
# </ObjectName> which indicates the end of the object definition
#
# For each line that looks like "Keyword value", the "keyword"
# virtual function
# is called, and the subclass is expected to make sense of the 
# keyword else return 0
#
# For each line that looks like <ObjectName arg>, the "object"
# virtual function
# is called
# $file is a filehandle
# $filename is an optional file name. If not present, the name of the 
# main configuration file is used
sub parse
{
    my ($self, $file, $filename) = @_;

    my $line;  # Use this to assemble continued lines

    $filename = $main::config_file unless $filename;

    while (<$file>)
    {
#	print "parsing for $self: $_\n"; # test

	# Strip leading and trailing white space
	$_ =~ s/^\s*//;
	$_ =~ s/\s*$//;

	# Ignore blank lines and lines beginning with hash
	next if $_ eq '';
	next if $_ =~ /^#/;

	$line .= $_;
	next if ($line =~ s/\\$//); # Line continuation

	# Look for </Objectname> to end the object definition
	last if ($line =~ /^<\/([^>]*)>/);

#	print "parsing: $line\n";
	if ($line =~ /^<\s*(\S*)\s*(.*)>/s)
	{
	    # <objecttype name>
	    # Start of an object definition
	    # pass it off to virtual function 
	    # for handling, and presumably to create a new object
	    # from it. If the handler doesnt understand it, error and try
	    # to absorb the rest of the clause
	    if (!$self->object($file, $1, $2))
	    {
		$self->log($main::LOG_ERR, "Unknown object '$1' in $filename line $.");
		
		my $depth = 1;
		# Absorb up to the next matching object end
		while (<$file>)
		{
		    # Strip leading and trailing white space
		    s/^\s*//;
		    s/\s*$//;
		    # Ignore blank lines and lines beginning with hash
		    next if $_ eq '' || /^#/;
		    $depth-- if /^<\/([^>]*)>/;
		    last if $depth <= 0;
		    $depth++ if /^<\s*(\S*)\s*(.*)>/;
		}
	    }
	}
	elsif ($line =~ /^(\S*)\s*(.*)/s)
	{
	    # keyword value
	    my ($keyword, $value) = ($1, $2);

	    $value = $self->file_substitution($value);
	    $value =~ s/\\(\d{3})/chr(oct($1))/ge; # Convert escaped octal

	    # Its a keyword for this object, pass it to the
	    # keyword recogniser, 
	    $self->keyword($file, $keyword, $value)
		|| $self->log($main::LOG_ERR, 
			"Unknown keyword '$keyword' in $filename line $.");
	}
	else
	{
	    $self->log($main::LOG_ERR, "Bad format in $filename line $.");
	}
	$line = '';
    }
}

#####################################################################
# If value looks like file:"filename", substitute the named file
# Contributed by Lars Marowsky-BrÅÈe <lmb@teuto.net>
# TODO: Allow "sh-style" `` command expansion
#
# If the value looks like sql:identifier:query, it will look for an AuthBy SQL 
# clause withan Identifier
# of 'identifier' and run the SQL query given by 'query'. The resulting first row
# in the result will be used to set the parameter ParameterName. 
sub file_substitution
{
    my ($self, $value) = @_;

    if ($value =~ /^file:\"(.*)\"$/) 
    {
	my $file = &Radius::Util::format_special($1, undef, $self);
	local *INCLUDE;
	if (open(INCLUDE, $file))
	{
	    my $oldrs = $/;
	    undef $/; 
	    $value = <INCLUDE>; # Slurp the whole file
	    $/ = $oldrs;
	    chomp $value; # Remove any newlines at the end of file
	}
	else
	{
	    $self->log($main::LOG_ERR, "Could not open file '$file' for parameter $value: $!");
	    $value = '';
	}
    }
    elsif ($value =~ /^sql:(.*?):(.*)$/) 
    {
	my ($identifier, $query) = ($1, $2);
	require Radius::SqlDb;
	my $db = &Radius::Configurable::find('AuthBy', $identifier);
	if ($db)
	{
	    ($value) = $db->queryOneRow($query);
	}
	else
	{
	    $self->log($main::LOG_ERR, "Could not find SQL clause '$identifier' to query configuration value");
	    $value = '';
	}
    }
    return $value;
}

#####################################################################
# Construct this object from a config file
sub readFile
{
    my ($self, $filename) = @_;
    
    local *CONFIG; # for recursive includes
    if (open(CONFIG, $filename))
    {
	$self->parse(*CONFIG, $filename);
	close(CONFIG);
	return $self;
    }
    return; # Failed
}

#####################################################################
# Pure virtual object handler, it must be overridden by subclasses
# This will be called each time there a <ObjectName ...> line in the
# config file.
# If the subclass doesnt understand ObjectName, it should return 0
# The default behaviour is just to load and create an instance of the
# the right object class, and push it onto the list of similar objects
# in $self->{$keyword}
sub object
{
    my ($self, $file, $keyword, @args) = @_;

    return $self->loadAndUse($file, $keyword, @args);
}

#####################################################################
# Pure virtual keyword handler, it must be overridden by subclasses
# This will be called each time there a "Keyword value" line in the
# config file that is not recognied in the ConfigKeywords hash
# If the subclass doesnt understand Keyword it should call the superclass
# If no class undestands it, it will be interpreted according to 
# ConfigKeywords
sub keyword
{
    my ($self, $file, $keyword, $value) = @_;

    if (lc $keyword eq 'include')
    {
	# Handle recursive file inclusion
	my $include_file = &Radius::Util::format_special($value);
	# May be a glob
	foreach (glob($include_file))
	{
	    $self->log($main::LOG_DEBUG, "include $_");
	    $self->readFile($_)
		or die "Could not open include file '$_': $!";
	}
	return 1;
    }
    else
    {
	# Look for the keyword in ConfigKeywords for this class
	# or any superclass
	return $self->set($keyword, $value);
    }
}

#####################################################################
# Sets a configuration paramter in this object, using the
# paramter descriptions for htis class and all its superclasses
sub set
{
    my ($self, $keyword, $value) = @_;

    return $self->configKeyword(ref($self), $keyword, $value);
}
# Clear a keyword
sub clear
{
    my ($self, $keyword) = @_;
    delete $self->{$keyword};
}

#####################################################################
# Try to match a keyword in the ConfigKeywords hash for the given class.
# If that fails, try to find a match in any of its superclasses
# according to @ISA
sub configKeyword
{
    my ($self, $class, $keyword, $value) = @_;

    no strict 'refs'; # So we can use symbolic references
    return 1 if $self->setKeyword($keyword, $value, 
				  \%{"${class}::ConfigKeywords"});
    # Not in the ConfigKeywords for this class, now try
    # all the superclasses named in ISA, left-to-right, depth first
    # as per the perl inheritance hierarchy until found
    foreach (@{"${class}::ISA"})
    {
	return 1 if $self->configKeyword($_, $keyword, $value);
    }
    return 0; # Not recognised in this class or any superclass
}

#####################################################################
# Return an array of all the ConfigKeywords and their values
# in subclass to superclass order, so that it may be assigned
# to a hash and get the correct overriding behaviour
# If $class is not specified, start with the actual class of $self
sub configKeywords
{
    my ($self, $class) = @_;

    my @result;

    $class = ref($self) unless $class;

    no strict 'refs'; # So we can use symbolic references
    # First get the superclass keywords
    map push(@result, $self->configKeywords($_)), @{"${class}::ISA"};

    # Then this class keywords
    push(@result, %{"${class}::ConfigKeywords"});
    use strict 'refs';
    return @result;
}

#####################################################################
# Generic function to check keywords against a table of 
# permitted keywords, and set the appropriate attribute in self
# $ktable is a reference to a keyword descriptor hash
# Return 1 if an entry is found and called
sub setKeyword
{
    my ($self, $keyword, $value, $ktable) = @_;

    #print "setKeyword $self, $keyword, $value, $ktable\n";
    # First find out what type of keyword it is.
    my $type = $$ktable{$keyword} || return 0;
    
    # Historical configKeywords had only a keyword type, not an array
    $type = $type->[0] if ref($type) eq 'ARRAY';

    # Then process the keyword value according to the data type
    # find the processing function
    my $fn = $keywordDataTypes{$type} || return 0;

    # and call it
    &{$fn}($self, $keyword, $value);
    return 1;
}

#####################################################################
# Generic function to check keywords against a table of 
# permitted keywords, and set the appropriate attribute in self
# Obsolete, and only retained for compatibility with legacy
# AuthBy code.
# REVISIT: remove one day
sub match_keyword
{
    my ($self, $keyword, $value, %ktable) = @_;

    return $self->setKeyword($keyword, $value, \%ktable);
}

#####################################################################
# Register an object in the registry so that it can be found
# by its Identifier
sub registerAs
{
    my ($self, $objtype, $id) = @_;

    $Radius::Configurable::byId{$objtype}{$id}  = $self;
}

#####################################################################
# Returns true if radiusd was invoked just to do configuration file
# check
sub isCheckingConfiguration
{
    my ($self) = @_;

    return $main::opt_c;
}

#####################################################################
# Load a particular class module and construct and return an instance
# return undef if it didnt work
sub load
{
    my ($file, $class, @args) = @_;

    my $ret;
    return unless eval("require $class") && ($ret = $class->new($file, @args));
    $ret->check_config();
    $ret->activate() unless $ret->isCheckingConfiguration();

    # Here we keep a directory for each type of object that wants
    # itself remembered by its Identifier. Set ObjType and Identifier
    # for any object that needs to be found by Identifier
    $ret->registerAs($ret->{ObjType}, $ret->{Identifier})
	if defined $ret->{ObjType} && defined $ret->{Identifier};

    return $ret; 
}

#####################################################################
# Load a particular class and construct one. Push it on to the list
# of similar objects we want to use
sub loadAndUse
{
    my ($self, $file, $objtype, $name, @args) = @_;

    # Map internal object type + name to external perl module names
    # This is a bit ugly, but its an historical accident
    my $class;
    if ($objtype eq 'AuthBy')
    {
	$class = "Radius::Auth$name";
    }
    elsif ($objtype eq 'AuthLog')
    {
    	$class = "Radius::AuthLog$name";
    }	    
    elsif ($objtype eq 'SessionDatabase')
    {
	$class = "Radius::Sess$name";
    }
    elsif ($objtype eq 'AddressAllocator')
    {
	$class = "Radius::AddressAllocator$name";
    }
    elsif ($objtype eq 'StatsLog')
    {
	$class = "Radius::StatsLog$name";
    }
    elsif ($objtype eq 'Log')
    {
	$class = "Radius::Log$name";
    }
    else
    {
	# Assume its some other object type, probably its Client
	# Realm, Handler etc.
	$class = "Radius::$objtype";
    }

    my $o = load($file, $class, $name, @args);
    if (!$o)
    {
	$self->log($main::LOG_ERR, "Could not load $objtype module $class: $@");
	return;
    }
    push(@{$self->{$objtype}}, $o);
    return $o;
}

#####################################################################
# Find the an object in the registry with the identifier name given
sub find
{
    my ($objtype, $identifier) = @_;

    return $Radius::Configurable::byId{$objtype}{$identifier};
}

#####################################################################
# Find an object by type and ID and push it onto an array of similar objects
# Return undef if not found
sub findAndUse
{
    my ($self, $objtype, $identifier) = @_;

    my $o;
    if ($o = find($objtype, $identifier))
    {
	push(@{$self->{$objtype}}, $o);
	return $o;
    }
    $self->log($main::LOG_WARNING, "Could not find $objtype clause with Identifier $identifier");
    return;
}

#####################################################################
# Run a hook with the given name if there is one defined
sub runHook
{
    my ($self, $hookname, $p, @args) = @_;

    my @result;
    if (defined $self->{"$hookname.compiled"})
    {
 	# We use an eval so an error in the hook wont kill us.
 	eval{ @result = &{$self->{"$hookname.compiled"}}(@args); };
 	$self->log($main::LOG_ERR, "Error in $hookname(): $@", $p) if $@;
    }
    return @result;
}

#####################################################################
# This function is called automatically during a SIGHUP,
# Make sure we dont retain any references to registered objects
sub reinitialize
{
    %Radius::Configurable::byId = ();
}

#####################################################################
# Log a message to the logging system. First, any private loggers
# for this object are called, then the global system loggers
# You could override this in your own class to log to whatever
# you like.
# @args is $priority, $string, $currentpacket
my $in_log;
sub log
{
    my ($self, @args) = @_;

    return if $in_log++; # Prevent recursion

    # Call each private log module with $priority, $string, $currentpacket
    map $_->log(@args), @{$self->{Log}};

    # Then call any global loggers
    &main::log(@args);
    $in_log = 0;
}

#####################################################################
# Recursively save this object and sub-objects named in objectlists
# $alreadyseen is a ref to a hash of objects that we have already processed, 
# in order to prevent recursion and multiple saving.
sub save_object
{
    my ($self, $file, $alreadyseen, $indentlevel) = @_;


    my $oheader = '';  # If a clause, the caluse opener
    my $otrailer = ''; # If a clause the clause closer
    my $pname;         # If not a clause, the parameter name

    my $objtype = ref($self);

    $indentlevel += 0;
    my $indent = "\t" x $indentlevel;
    # Deal with historical object naming conventions
    if ($objtype =~ /Radius::AuthLog(.*)/)
    {
	$oheader  = $indent . "<AuthLog $1>\n";
	$otrailer = $indent . "</AuthLog>\n";
    }
    elsif ($objtype =~ /Radius::Auth(.*)/)
    {
	$oheader  = $indent . "<AuthBy $1>\n";
	$otrailer = $indent . "</AuthBy>\n";
	$pname    = $indent . 'AuthBy';
    }
    elsif ($objtype =~ /Radius::Sess(.*)/)
    {
	$oheader  = $indent . "<SessionDatabase $1>\n";
	$otrailer = $indent . "</SessionDatabase>\n";
    }
    elsif ($objtype =~ /Radius::AddressAllocator(.*)/)
    {
	$oheader  = $indent . "<AddressAllocator $1>\n";
	$otrailer = $indent . "</AddressAllocator>\n";
    }
    elsif ($objtype =~ /Radius::StatsLog(.*)/)
    {
	$oheader  = $indent . "<StatsLog $1>\n";
	$otrailer = $indent . "</StatsLog>\n";
    }
    elsif ($objtype =~ /Radius::Log(.*)/)
    {
	$oheader  = $indent . "<Log $1>\n";
	$otrailer = $indent . "</Log>\n";
    }
    elsif ($objtype =~ /Radius::ServerConfig/)
    {
	# No object encapsulation
    }
    elsif ($objtype =~ /Radius::Realm/)
    {
	# Funny naming conventions
	my $name = $_->{Name};
	$name =~ s/^Realm=//;
	$oheader  = $indent . "<Realm $name>\n";
	$otrailer = $indent . "</Realm>\n";
    }
    elsif ($objtype =~ /Radius::(.*)/)
    {
	$oheader  = $indent . "<$1 $_->{Name}>\n";
	$otrailer = $indent . "</$1>\n";
    }
    else
    {
	$self->log($main::LOG_ERR, "Dont know how to save object of type $objtype");
	return;
    }

    # See if we have already dumped this object, and see if we can just 
    # refer to its Identifier
    if ($$alreadyseen{$self})
    {
	if (defined $pname)
	{
	    if (defined $self->{Identifier})
	    {
		print $file "$pname $self->{Identifier}\n";
		return;
	    }
	    else
	    {
		$self->log($main::LOG_ERR, "Object $objtype has already been saved but has no Identifier to refer to it. Dropped.");
		return;
	    }
	}
	# Otherwise we just ignore it
	return;
    }

    $$alreadyseen{$self}++;


    # Dont dump the default logger, it will be created by Trace and LogFile keywourds
    return if ($objtype eq 'Radius::LogFILE' && $self->{Name} eq 'DEFAULT');

    print $file "\n";
    print $file $oheader;

    my %configKeywords = $self->configKeywords();
    $indent = "\t" x ($indentlevel + 1); # Deeper
    foreach (sort keys %configKeywords)
    {
	next unless defined $self->{$_};

	# Omit obsolete or duplicate keywords:
	next if $objtype eq 'Radius::AuthRADIUS' && $_ eq 'Host';

	# Handle historical configKeywords that only had the keyword type
	# and no documentation
	my $configtype = $configKeywords{$_};
	$configtype = $configtype->[0] if ref($configtype) eq 'ARRAY';

	if ($configtype eq 'objectlist')
	{
	    next; # Do all the objects later
	}
	elsif ($configtype eq 'flag')
	{
	    print $file $indent . $_ . ' ' . ($self->{$_} ? '1' : '0') . "\n";
	}
	elsif (   $configtype eq 'stringarray' 
	       || $configtype eq 'splitstringarray' )
	{
	    my $keyword = $_;
	    foreach (@{$self->{$_}})
	    {
		print $file $indent . $keyword . ' ' . $_ . "\n";
	    }
	}
	elsif (   $configtype eq 'stringhash' )
	{
	    my $keyword = $_;
	    foreach (sort {$a <=> $b} keys %{$self->{$keyword}})
	    {
		print $file $indent . $keyword . ' ' . $_ . ',' . ${$self->{$keyword}}{$_} . "\n";
	    }
	}
	elsif (   $configtype eq 'splitstringhash' )
	{
	    my $keyword = $_;
            my $svalue;
	    foreach (sort keys %{$self->{$keyword}})
	    {
		$svalue = $_ . ",";
		foreach (@{$self->{$keyword}}{$_}) 
		{
		    $svalue .= join (',', @{$_});
		}
            }
	    print $file $indent . $keyword . ' ' . $svalue . "\n";
	}
	elsif ($configtype eq 'counthash')
	{
	    print $file $indent . $_ . ' ' . join(' ', keys %{$self->{$_}}) . "\n";
	}
	else
	{
	    my $value = $self->{$_};
	    # Escape any newlines
	    $value =~ s/\n/\\\n/g;
	    # Except of the last newline. Put it back unescaped.
	    $value =~ s/\\\n$/\n/;
	    print $file $indent . "$_ $value\n";
	}
    }

    # Now do all the objectlists
    foreach (sort keys %configKeywords)
    {
	my $configtype = $configKeywords{$_};
	$configtype = $configtype->[0] if ref($configtype) eq 'ARRAY';
	next unless $configtype eq 'objectlist';
	next unless exists $self->{$_}; # Prevent auto-vivify
	foreach (@{$self->{$_}})
	{
	    $_->save_object($file, $alreadyseen, $indentlevel + 1);
	}
    }

    print $file $otrailer;
}


#####################################################################
# Some routines to support packet fiddling in some of our subclasses
#####################################################################

#####################################################################
# Adjust the reply packet with the StripFromReply, AddToReply
# and DefaultReply parameters
# If $do_address is set, then we should do address allocation
# if possible
sub adjustReply
{
    my ($self, $p) = @_;

    # Never add to an Access-Reject
    return if $p->code() eq 'Access-Reject';

    # Handle FramedGroup parameter if there is not already 
    # a static address
    $self->handle_framedgroup($p, $self->{FramedGroup})
	if defined $self->{FramedGroup};

    map {$p->{rp}->delete_attr($_)} (split(/\s*,\s*/, $self->{StripFromReply}))
	if defined $self->{StripFromReply};

    $p->{rp}->delete_attr_fn
	(sub {return $_[0] =~ /^Unknown/; })     # Possibly strip attributes that were not known in dictionary
	    if (!$main::config->{ProxyUnknownAttributes} && $p->{rp}->{UnknownAttributeCount});

    # This is the complement of StripFromReply
    $p->{rp}->delete_attr_fn
	(sub {!grep($_[0] eq $_, 
		    split(/\s*,\s*/, $self->{AllowInReply}))})
	    if defined $self->{AllowInReply};

    # use default REPLY if no REPLY attributes are defined
    $self->addReplyItems($p, &Radius::Util::splitAttrVals($self->{DefaultReply}))
	if (defined $self->{DefaultReply} && $p->{rp}->attr_count() == 0);

    $self->addReplyItems($p, &Radius::Util::splitAttrVals($self->{AddToReply}))
	if defined $self->{AddToReply};

    if (defined $self->{AddToReplyIfNotExist})
    {
	foreach (&Radius::Util::splitAttrVals(&Radius::Util::format_special($self->{AddToReplyIfNotExist}, $p)))
	{
	    $self->addReplyItem($_->[0], $_->[1], $p)
		unless defined $p->{rp}->get_attr($$_[0]);
	}
    }
}

#####################################################################
# Process and append a single reply attribute and value
# to the reply. Special handling for some attributes
# if $replace is set, any existing attribute is replaced
sub addReplyItems
{
    my ($self, $p, @attrvals) = @_;

    my $av;
    foreach $av (@attrvals)
    {
	$self->addReplyItem($$av[0], $$av[1], $p);
    }
}

#####################################################################
# Process and append a single reply attribute and value
# to the reply. Special handling for some attributes
sub addReplyItem
{
    my ($self, $name, $value, $p) = @_;

    # Honour special formatting
    $value = &Radius::Util::format_special($value, $p);

    if ($name eq 'Framed-Group')
    {
	$self->handle_framedgroup($p, $value);
    }
    else
    {
	if ($name eq 'MS-CHAP-MPPE-Keys')
	{
	    if (length($value) != 24)
	    {
		# Need to encode the plaintext secret
		require Radius::MSCHAP;
		$value = pack('a8 a16',  
			    Radius::MSCHAP::LmPasswordHash($value),
			    Radius::MSCHAP::NtPasswordHash
			      (Radius::MSCHAP::NtPasswordHash
			       (Radius::MSCHAP::ASCIItoUnicode($value))));
		
	    }
	}
	elsif ($name eq 'Session-Timeout' && $value =~ /until\s*(.*)/)
	{
	    if ($1 eq 'Time')
	    {
		# Look for the end time that should have
		# been cached by the Time check item. It is the 
		# time-of-day that the session will end. Assumption
		# is that it is today
		if (defined $p->{TimeEnd})
		{
		    $value = $p->{TimeEnd} - time;
		}
		else
		{	
		    $self->log($main::LOG_DEBUG, 
		       "Session-Timeout=\"until Time\" was specified, but there was no Time check item for this user. Ignored.");
		}
	    }
	    elsif ($1 eq 'Expiration' || $1 eq 'ValidTo')
	    {
		# Look for the end time that should have
		# been cached by the Expiration or ValidTo check item. It is the 
		# time-of-day that the session will end. Assumption
		# is that it is today
		if (defined $p->{ValidTo})
		{
		    $value = $p->{ValidTo} - time;
		}
		else
		{	
		    $self->log($main::LOG_DEBUG, 
		       "Session-Timeout=\"until ValidTo\" was specified, but there was no ValidTo or Expiration check item for this user. Ignored.");
		}
	    }
	    elsif ($1 =~ /^(\d{2})(\d{2})$/)
	    {
		# Compute the Session-Timeout in seconds until 
		# the next time-of-day.
		my @time = localtime(time);
		$time[0] = 0; # Seconds
		$time[1] = $2;
		$time[2] = $1;
		my $endtime = timelocal(@time);
		$endtime += 24 * 60 * 60 if $endtime < time;
		$value = $endtime - time;
	    }
	}
	
	# Safe to add it to the reply attributes
	# Maybe do replacements on reply
	# attributes first
	$value = &Radius::Util::format_special($value, $p)
	    if grep $name eq $_, @{$self->{DynamicReply}};
	
	$p->{rp}->add_attr($name, $value);
    }
}

#####################################################################
# This is to handle FramedGroup Realm request or Framed-Group 
# user attribute
# it takes return packet, group value and packet flag as parameters.
sub handle_framedgroup
{
    my ($self, $p, $value) = @_;

    # Dont do this if there is already an IP address
    return if defined $p->{rp}->getAttrByNum
	($Radius::Radius::FRAMED_IP_ADDRESS);

    $self->log($main::LOG_DEBUG,
		"FramedGroup $value address is being assigned", $p);

    # Figure out an address to allocate
    my $base = $p->{Client}->{FramedGroupBaseAddress}[$value];
    if (!defined $base)
    {
	$self->log($main::LOG_WARNING, 
		   "There is no FramedGroupBaseAddress defined for a Framed-Group of $value. No address will be allocated", $p);
	return;
    }
    if ($p->{Client}->{FramedGroupMaxPortsPerClassC} == 0)
    {
	$self->log($main::LOG_WARNING, 
		   "FramedGroupMaxPortsPerClassC is 0. No address will be allocated", $p);
	return;
    }
	
    my @base = split(/\./, $base);
    my $port = $p->getAttrByNum($Radius::Radius::NAS_PORT);
    # Adjust port number by subtracting an offset. Cisco ISDN port numbers start
    # at a silly number
    $port -= $p->{Client}->{FramedGroupPortOffset}
        if $port > $p->{Client}->{FramedGroupPortOffset};

    # Compute octet 4 of the IP address
    my $o4 = $base[3] + ($port % $p->{Client}->{FramedGroupMaxPortsPerClassC}); 
    # Compute octet 3 of the IP address
    my $o3 = ($base[2] + int($port / $p->{Client}->{FramedGroupMaxPortsPerClassC})) % 256;
    
    $p->{rp}->changeAttrByNum($Radius::Radius::FRAMED_IP_ADDRESS, 
			      "$base[0].$base[1].$o3.$o4");
	
}

#####################################################################
# Overridable function which quotes strings in a module dependent way.
# This is defined as UNIVERSAL insterad of Configurable, 
# since the order of ISA might otherwise
# mean that a module gets Configurable::quote instead of SqlDb::quote
sub UNIVERSAL::quote
{
    return '\'' . $_[1] . '\'';
}

#####################################################################
# Return the current time in standard perl time string formatted
# Append microseconds if so configured
sub format_ctime
{
    my ($self) = @_;

    my ($seconds, $micro) = &Radius::Util::getTimeHires();
    if ($self->{LogMicroseconds} || $main::config->{LogMicroseconds})
    {
	return localtime($seconds) . sprintf(" %06d", $micro);
    }
    else
    {
	return scalar localtime($seconds);
    }
}

# Each sub returns true if the policy requies to continue
my %authPolicies =
(
 'ContinueWhileIgnore'    => sub {return $_[0] == $main::IGNORE},
 'ContinueUntilIgnore'    => sub {return $_[0] != $main::IGNORE},
 'ContinueWhileAccept'    => sub {return $_[0] == $main::ACCEPT},
 'ContinueUntilAccept'    => sub {return $_[0] != $main::ACCEPT},
 'ContinueWhileChallenge' => sub {return $_[0] == $main::CHALLENGE},
 'ContinueUntilChallenge' => sub {return $_[0] != $main::CHALLENGE},
 'ContinueWhileReject'    => sub {return $_[0] == $main::REJECT 
				   || $_[0] == $main::REJECT_IMMEDIATE},
 'ContinueUntilReject'    => sub {return $_[0] != $main::REJECT
				   && $_[0] != $main::REJECT_IMMEDIATE},
 'ContinueWhileAcceptOrChallenge' => sub {return $_[0] == $main::ACCEPT 
				   || $_[0] == $main::CHALLENGE},
 'ContinueUntilAcceptOrChallenge' => sub {return $_[0] != $main::ACCEPT 
				   && $_[0] != $main::CHALLENGE},
 'ContinueAlways'         => sub {return 1;},
 );

#####################################################################
# Evaluates an authentication result against the policy string
# Returns true if policy is to continue
sub evaluatePolicy
{
    my ($self,  $policy, $result) = @_;

    my $r = 1; # Unrecognised policies always succeed
    $r = &{$authPolicies{$policy}}($result) 
	if exists $authPolicies{$policy};
    return $r;
}

#####################################################################
# Remove any circular references that would prevent auto destruction
# Override if you need that
sub destroy
{
    my ($self) = @_;
}

#sub DESTROY
#{
#    my ($self) = @_;
#    print "FIXME: Configurable $self destroyed\n";
#}

1;
